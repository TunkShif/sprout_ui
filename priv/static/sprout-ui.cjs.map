{
  "version": 3,
  "sources": ["../../assets/js/sprout-ui/index.ts", "../../assets/js/sprout-ui/utils/body-scroll.ts", "../../assets/js/sprout-ui/components/global.ts", "../../assets/js/sprout-ui/internal/decorators.ts", "../../assets/node_modules/.pnpm/tabbable@6.0.1/node_modules/tabbable/src/index.js", "../../assets/node_modules/.pnpm/focus-trap@7.1.0/node_modules/focus-trap/index.js", "../../assets/js/sprout-ui/utils/index.ts", "../../assets/js/sprout-ui/utils/disposables.ts", "../../assets/js/sprout-ui/internal/modal.ts", "../../assets/js/sprout-ui/internal/sprout-element.ts", "../../assets/js/sprout-ui/internal/transition.ts", "../../assets/js/sprout-ui/components/dialog.ts", "../../assets/node_modules/.pnpm/@floating-ui+core@1.0.1/node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs", "../../assets/node_modules/.pnpm/@floating-ui+dom@1.0.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs", "../../assets/js/sprout-ui/components/floating.ts", "../../assets/js/sprout-ui/components/popover.ts", "../../assets/js/sprout-ui/components/tooltip.ts"],
  "sourcesContent": ["import global from \"./components/global\"\nimport type { SproutComponent, SproutHook } from \"./types\"\n\ntype CreateSproutConfigOptions = {\n  components: SproutComponent[]\n}\n\ntype CreateSproutConfig = (opts: CreateSproutConfigOptions) => {\n  initComponents: () => void\n  hooks: { [key: string]: SproutHook }\n  handleDomChange: (from: HTMLElement, to: HTMLElement) => void\n}\n\nexport const createSproutConfig: CreateSproutConfig = (opts) => {\n  const components = [global(), ...opts.components]\n  return {\n    initComponents: () => {\n      components.forEach((comp) => comp.init?.())\n    },\n    hooks: Object.assign({}, ...components.map((comp) => comp.hook?.())),\n    handleDomChange: (from: HTMLElement, to: HTMLElement) => {\n      components.forEach((comp) => comp.handleDomChange?.(from, to))\n    }\n  }\n}\n\nexport * from \"./components\"\nexport * from \"./types\"\n", "export const toggleBodyScroll = (state?: \"on\" | \"off\") => {\n  if (!state) return\n  switch (state) {\n    case \"on\":\n      Object.assign(document.body.style, { overflow: \"\" })\n      break\n    case \"off\":\n      Object.assign(document.body.style, { overflow: \"hidden\" })\n      break\n  }\n}\n", "import { toggleBodyScroll } from \"../utils/body-scroll\"\nimport type { SproutComponentSetup, SproutEvent } from \"../types\"\n\ntype ToggleAttributeEvent = SproutEvent<{ attribute: string; states: [string, string] }>\ntype ToggleBodyScrollEvent = SproutEvent<{ state: \"on\" | \"off\" }>\n\nconst init = () => {\n  window.addEventListener(\"sp:toggle-attribute\", (e) => {\n    const { target, detail } = e as ToggleAttributeEvent\n    const state =\n      target.getAttribute(detail.attribute) === detail.states[0]\n        ? detail.states[1]\n        : detail.states[0]\n    target.setAttribute(detail.attribute, state)\n  })\n\n  window.addEventListener(\"sp:toggle-body-scroll\", (e) => {\n    const { detail } = e as ToggleBodyScrollEvent\n    toggleBodyScroll(detail.state)\n  })\n}\n\nconst global: SproutComponentSetup = () => ({\n  init\n})\n\nexport default global\n", "export const query = (part: string) => (target: HTMLElement, propertyKey: string) => {\n  const key = `_${propertyKey}`\n  Reflect.defineProperty(target, propertyKey, {\n    get(this: any) {\n      if (this[key] === undefined) {\n        this[key] = this.querySelector(`[data-part=\"${part}\"]`)\n      }\n      return this[key]\n    },\n    enumerable: true,\n    configurable: true\n  })\n}\n\nexport const attr =\n  (name: string, converter?: (val: string | null) => any) =>\n    (target: HTMLElement, propertyKey: string) => {\n      Reflect.defineProperty(target, propertyKey, {\n        get(this: HTMLElement) {\n          const value = this.getAttribute(name)\n          return !!converter ? converter(value) : value\n        },\n        set(this: HTMLElement, value: any) {\n          this.setAttribute(name, value)\n        },\n        enumerable: true,\n        configurable: true\n      })\n    }\n", "const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]:not(slot)',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary:first-of-type',\n  'details',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst NoElement = typeof Element === 'undefined';\n\nconst matches = NoElement\n  ? function () {}\n  : Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\nconst getRootNode =\n  !NoElement && Element.prototype.getRootNode\n    ? (element) => element.getRootNode()\n    : (element) => element.ownerDocument;\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nconst getCandidates = function (el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nconst getCandidatesIteratively = function (\n  elements,\n  includeContainer,\n  options\n) {\n  const candidates = [];\n  const elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    const element = elementsToCheck.shift();\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      const assigned = element.assignedElements();\n      const content = assigned.length ? assigned : element.children;\n      const nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push(...nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates,\n        });\n      }\n    } else {\n      // check candidate element\n      const validCandidate = matches.call(element, candidateSelector);\n      if (\n        validCandidate &&\n        options.filter(element) &&\n        (includeContainer || !elements.includes(element))\n      ) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      const shadowRoot =\n        element.shadowRoot ||\n        // check for an undisclosed shadow\n        (typeof options.getShadowRoot === 'function' &&\n          options.getShadowRoot(element));\n\n      const validShadowRoot =\n        !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        const nestedCandidates = getCandidatesIteratively(\n          shadowRoot === true ? element.children : shadowRoot.children,\n          true,\n          options\n        );\n\n        if (options.flatten) {\n          candidates.push(...nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: nestedCandidates,\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift(...element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\nconst getTabindex = function (node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if (\n      (isScope ||\n        /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) ||\n        node.isContentEditable) &&\n      isNaN(parseInt(node.getAttribute('tabindex'), 10))\n    ) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || getRootNode(node);\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nconst isNodeAttached = function (node) {\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  let nodeRootHost = getRootNode(node).host;\n  let attached = !!(\n    nodeRootHost?.ownerDocument.contains(nodeRootHost) ||\n    node.ownerDocument.contains(node)\n  );\n\n  while (!attached && nodeRootHost) {\n    // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n    //  which means we need to get the host's host and check if that parent host is contained\n    //  in (i.e. attached to) the document\n    nodeRootHost = getRootNode(nodeRootHost).host;\n    attached = !!nodeRootHost?.ownerDocument.contains(nodeRootHost);\n  }\n\n  return attached;\n};\n\nconst isZeroArea = function (node) {\n  const { width, height } = node.getBoundingClientRect();\n  return width === 0 && height === 0;\n};\nconst isHidden = function (node, { displayCheck, getShadowRoot }) {\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (\n    !displayCheck ||\n    displayCheck === 'full' ||\n    displayCheck === 'legacy-full'\n  ) {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      const originalNode = node;\n      while (node) {\n        const parentElement = node.parentElement;\n        const rootNode = getRootNode(node);\n        if (\n          parentElement &&\n          !parentElement.shadowRoot &&\n          getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    let parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *')\n              ? true\n              : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0 ||\n    !isNodeMatchingSelectorFocusable(options, node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isValidShadowRootTabbable = function (shadowHostNode) {\n  const tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nconst sortByOrder = function (candidates) {\n  const regularTabbables = [];\n  const orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    const isScope = !!item.scopeParent;\n    const element = isScope ? item.scopeParent : item;\n    const candidateTabindex = getTabindex(element, isScope);\n    const elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope\n        ? regularTabbables.push(...elements)\n        : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements,\n      });\n    }\n  });\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .reduce((acc, sortable) => {\n      sortable.isScope\n        ? acc.push(...sortable.content)\n        : acc.push(sortable.content);\n      return acc;\n    }, [])\n    .concat(regularTabbables);\n};\n\nconst tabbable = function (el, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable,\n    });\n  } else {\n    candidates = getCandidates(\n      el,\n      options.includeContainer,\n      isNodeMatchingSelectorTabbable.bind(null, options)\n    );\n  }\n  return sortByOrder(candidates);\n};\n\nconst focusable = function (el, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot,\n    });\n  } else {\n    candidates = getCandidates(\n      el,\n      options.includeContainer,\n      isNodeMatchingSelectorFocusable.bind(null, options)\n    );\n  }\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n", "import { tabbable, focusable, isFocusable, isTabbable } from 'tabbable';\n\nconst rooTrapStack = [];\n\nconst activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  },\n};\n\nconst isSelectableInput = function (node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n};\n\nconst isEscapeEvent = function (e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nconst isTabEvent = function (e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nconst delay = function (fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nconst findIndex = function (arr, fn) {\n  let idx = -1;\n\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nconst valueOrHandler = function (value, ...params) {\n  return typeof value === 'function' ? value(...params) : value;\n};\n\nconst getActualTarget = function (event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function'\n    ? event.composedPath()[0]\n    : event.target;\n};\n\nconst createFocusTrap = function (elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  const doc = userOptions?.document || document;\n\n  const trapStack = userOptions?.trapStack || rooTrapStack;\n\n  const config = {\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    ...userOptions,\n  };\n\n  const state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [], // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n  };\n\n  let trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  const getOption = (configOverrideOptions, optionName, configOptionName) => {\n    return configOverrideOptions &&\n      configOverrideOptions[optionName] !== undefined\n      ? configOverrideOptions[optionName]\n      : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  const findContainerIndex = function (element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(\n      ({ container, tabbableNodes }) =>\n        container.contains(element) ||\n        // fall back to explicit tabbable search which will take into consideration any\n        //  web components if the `tabbableOptions.getShadowRoot` option was used for\n        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n        //  look inside web components even if open)\n        tabbableNodes.find((node) => node === element)\n    );\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  const getNodeForOption = function (optionName, ...params) {\n    let optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue(...params);\n    }\n\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\n        `\\`${optionName}\\` was specified but was not a node, or did not return a node`\n      );\n    }\n\n    let node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\n          `\\`${optionName}\\` as selector refers to no known node`\n        );\n      }\n    }\n\n    return node;\n  };\n\n  const getInitialFocusNode = function () {\n    let node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        const firstTabbableGroup = state.tabbableGroups[0];\n        const firstTabbableNode =\n          firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error(\n        'Your focus-trap needs to have at least one focusable element'\n      );\n    }\n\n    return node;\n  };\n\n  const updateTabbableNodes = function () {\n    state.containerGroups = state.containers.map((container) => {\n      const tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n      const focusableNodes = focusable(container, config.tabbableOptions);\n\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode:\n          tabbableNodes.length > 0\n            ? tabbableNodes[tabbableNodes.length - 1]\n            : null,\n\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode(node, forward = true) {\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          const nodeIdx = focusableNodes.findIndex((n) => n === node);\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n\n          if (forward) {\n            return focusableNodes\n              .slice(nodeIdx + 1)\n              .find((n) => isTabbable(n, config.tabbableOptions));\n          }\n\n          return focusableNodes\n            .slice(0, nodeIdx)\n            .reverse()\n            .find((n) => isTabbable(n, config.tabbableOptions));\n        },\n      };\n    });\n\n    state.tabbableGroups = state.containerGroups.filter(\n      (group) => group.tabbableNodes.length > 0\n    );\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (\n      state.tabbableGroups.length <= 0 &&\n      !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error(\n        'Your focus-trap must have at least one container with at least one tabbable node in it at all times'\n      );\n    }\n  };\n\n  const tryFocus = function (node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({ preventScroll: !!config.preventScroll });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  const getReturnFocusNode = function (previousActiveElement) {\n    const node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  const checkPointerDown = function (e) {\n    const target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus:\n          config.returnFocusOnDeactivate &&\n          !isFocusable(target, config.tabbableOptions),\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  const checkFocusIn = function (e) {\n    const target = getActualTarget(e);\n    const targetContained = findContainerIndex(target) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  };\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  const checkTab = function (e) {\n    const target = getActualTarget(e);\n    updateTabbableNodes();\n\n    let destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      const containerIndex = findContainerIndex(target);\n      const containerGroup =\n        containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode =\n            state.tabbableGroups[state.tabbableGroups.length - 1]\n              .lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        let startOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ firstTabbableNode }) => target === firstTabbableNode\n        );\n\n        if (\n          startOfGroupIndex < 0 &&\n          (containerGroup.container === target ||\n            (isFocusable(target, config.tabbableOptions) &&\n              !isTabbable(target, config.tabbableOptions) &&\n              !containerGroup.nextTabbableNode(target, false)))\n        ) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          const destinationGroupIndex =\n            startOfGroupIndex === 0\n              ? state.tabbableGroups.length - 1\n              : startOfGroupIndex - 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        let lastOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ lastTabbableNode }) => target === lastTabbableNode\n        );\n\n        if (\n          lastOfGroupIndex < 0 &&\n          (containerGroup.container === target ||\n            (isFocusable(target, config.tabbableOptions) &&\n              !isTabbable(target, config.tabbableOptions) &&\n              !containerGroup.nextTabbableNode(target)))\n        ) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          const destinationGroupIndex =\n            lastOfGroupIndex === state.tabbableGroups.length - 1\n              ? 0\n              : lastOfGroupIndex + 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  const checkKey = function (e) {\n    if (\n      isEscapeEvent(e) &&\n      valueOrHandler(config.escapeDeactivates, e) !== false\n    ) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  const checkClick = function (e) {\n    const target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  const addListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus\n      ? delay(function () {\n          tryFocus(getInitialFocusNode());\n        })\n      : tryFocus(getInitialFocusNode());\n\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false,\n    });\n\n    return trap;\n  };\n\n  const removeListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n\n    get paused() {\n      return state.paused;\n    },\n\n    activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      const onActivate = getOption(activateOptions, 'onActivate');\n      const onPostActivate = getOption(activateOptions, 'onPostActivate');\n      const checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      const finishActivation = () => {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(\n          finishActivation,\n          finishActivation\n        );\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n\n    deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      const options = {\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus,\n        ...deactivateOptions,\n      };\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n\n      const onDeactivate = getOption(options, 'onDeactivate');\n      const onPostDeactivate = getOption(options, 'onPostDeactivate');\n      const checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      const returnFocus = getOption(\n        options,\n        'returnFocus',\n        'returnFocusOnDeactivate'\n      );\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(\n          getReturnFocusNode(state.nodeFocusedBeforeActivation)\n        ).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n\n    pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n\n      return this;\n    },\n\n    unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n\n      return this;\n    },\n\n    updateContainerElements(containerElements) {\n      const elementsAsArray = [].concat(containerElements).filter(Boolean);\n\n      state.containers = elementsAsArray.map((element) =>\n        typeof element === 'string' ? doc.querySelector(element) : element\n      );\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    },\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n\n  return trap;\n};\n\nexport { createFocusTrap };\n", "export const isTruthy = (val: any) => val !== null && val !== undefined\n\nexport const isVisible = (element: HTMLElement) =>\n  !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length > 0)\n\nexport const flipping = <T>(current: T, values: [T, T] = [\"open\", \"closed\"] as [T, T]) =>\n  current === values[0] ? values[1] : values[0]\n", "export default class Disposables {\n  private disposables: Function[] = []\n\n  add(callback: () => void) {\n    this.disposables.push(callback)\n    return () => {\n      let idx = this.disposables.indexOf(callback)\n      if (idx >= 0) {\n        let [dispose] = this.disposables.splice(idx, 1)\n        dispose()\n      }\n    }\n  }\n\n  nextFrame(callback: () => void) {\n    const raf = requestAnimationFrame(() => requestAnimationFrame(callback))\n    return this.add(() => cancelAnimationFrame(raf))\n  }\n\n  addEventListener<TEvent extends keyof HTMLElementEventMap>(\n    element: Element | Document,\n    event: TEvent | string,\n    listener: (event: HTMLElementEventMap[TEvent] | Event) => any,\n    options?: boolean | AddEventListenerOptions | undefined\n  ) {\n    element.addEventListener(event, listener, options)\n    return this.add(() => element.removeEventListener(event, listener))\n  }\n\n  setTimeout(handler: () => void, timeout?: number) {\n    const id = window.setTimeout(handler, timeout)\n    return this.add(() => clearTimeout(id))\n  }\n\n  dispose() {\n    this.disposables.splice(0).forEach((d) => d())\n  }\n}\n", "import { createFocusTrap } from \"focus-trap\"\nimport { isVisible } from \"../utils\"\nimport { toggleBodyScroll } from \"../utils/body-scroll\"\nimport Disposables from \"../utils/disposables\"\n\ninterface ModalOptions {\n  preventScroll?: boolean\n  dismissOnEsc?: boolean\n  dismissOnClickAway?: boolean\n}\n\nexport default class Modal {\n  private element: HTMLElement\n  private preventScroll: boolean\n  private dismissOnEsc: boolean\n  private dismissOnClickAway: boolean\n\n  private listeners = new Disposables()\n  private disposables = new Disposables()\n\n  constructor(element: HTMLElement, options?: ModalOptions) {\n    this.element = element\n\n    this.preventScroll = options?.preventScroll ?? true\n    this.dismissOnEsc = options?.dismissOnEsc ?? true\n    this.dismissOnClickAway = options?.dismissOnClickAway ?? true\n  }\n\n  addEventListeners(onDismiss: () => void) {\n    if (this.dismissOnClickAway) {\n      this.listeners.addEventListener(document, \"click\", (event) => {\n        if (isVisible(this.element) && !this.element.contains(event.target as Element)) {\n          onDismiss()\n          event.preventDefault()\n        }\n      })\n    }\n    if (this.dismissOnEsc) {\n      this.listeners.addEventListener(document, \"keydown\", (event) => {\n        const { key } = event as KeyboardEvent\n        if (isVisible(this.element) && key === \"Escape\") {\n          onDismiss()\n          event.preventDefault()\n        }\n      })\n    }\n  }\n\n  removeEventListeners() {\n    this.listeners.dispose()\n  }\n\n  activate() {\n    const focusTrap = createFocusTrap(this.element, {\n      escapeDeactivates: false,\n      allowOutsideClick: true\n    })\n    this.disposables.add(() => focusTrap.deactivate())\n    this.disposables.nextFrame(() => focusTrap.activate())\n    toggleBodyScroll(this.preventScroll ? \"off\" : undefined)\n  }\n\n  deactivate() {\n    this.disposables.dispose()\n    toggleBodyScroll(this.preventScroll ? \"on\" : undefined)\n  }\n}\n", "import { attr } from \"./decorators\"\n\nexport default class SproutElement<UIState extends string = \"open\" | \"closed\"> extends HTMLElement {\n  @attr(\"data-state\")\n  state: UIState\n\n  attributeChangedCallback(\n    attribute: string,\n    oldValue: string | undefined | null,\n    newValue: string | undefined | null\n  ) {\n    // `attributeChangedCallback` will be called when the component is mounted\n    // at the first time with a null `oldValue`, even though the attribute is\n    // set in the html, here we're preventing handle changes for this situation\n    if (oldValue === null && newValue !== null) return\n    if (oldValue === newValue) return\n    this.updatedCallback(attribute, oldValue, newValue)\n  }\n\n  updatedCallback(\n    _attribute: string,\n    _oldValue: string | undefined | null,\n    _newValue: string | undefined | null\n  ) { }\n\n  executeJs(element: HTMLElement, command: string | undefined | null) {\n    window.liveSocket.execJS(element, command || \"[]\")\n  }\n\n  setAttributeLive(element: HTMLElement, name: string, value: string) {\n    this.executeJs(element, JSON.stringify([[\"set_attr\", { attr: [name, value], to: null }]]))\n  }\n\n  removeAttributeLive(element: HTMLElement, name: string) {\n    this.executeJs(element, JSON.stringify([[\"remove_attr\", { attr: name, to: null }]]))\n  }\n\n  setStateLive(state: UIState) {\n    this.setAttributeLive(this, \"data-state\", state)\n  }\n}\n", "import Disposables from \"../utils/disposables\"\n\ntype TransitionStatus = \"ended\" | \"canceled\"\ntype TransitionStage = \"enter\" | \"leave\"\n\ninterface TransitionClasses {\n  enter: string[]\n  enterFrom: string[]\n  enterTo: string[]\n  leave: string[]\n  leaveFrom: string[]\n  leaveTo: string[]\n}\n\nconst getTransitionClasses = (element: HTMLElement) =>\n  Object.fromEntries(\n    [\"enter\", \"leave\"]\n      .map((v) => [v, `${v}From`, `${v}To`])\n      .flat()\n      .map((key) => [key, element.dataset[key]?.split(\" \")?.filter(Boolean) ?? []] as const)\n  ) as unknown as TransitionClasses\n\nconst waitForTransition = (element: HTMLElement, onDone: (status: TransitionStatus) => void) => {\n  let { transitionDuration, transitionDelay } = getComputedStyle(element)\n\n  let totalDuration = [transitionDuration, transitionDelay]\n    .map((value) => {\n      let [resolvedValue = 0] = value\n        .split(\",\")\n        .filter(Boolean)\n        .map((v) => (v.includes(\"ms\") ? parseFloat(v) : parseFloat(v) * 1000))\n        .sort((a, z) => z - a)\n\n      return resolvedValue\n    })\n    .reduce((a, b) => a + b, 0)\n\n  const d = new Disposables()\n\n  if (totalDuration === 0) {\n    onDone(\"ended\")\n  } else {\n    const listeners: (() => void)[] = []\n\n    listeners.push(\n      d.addEventListener(element, \"transitionrun\", (event) => {\n        if (event.target !== event.currentTarget) return\n\n        listeners.splice(0).forEach((d) => d())\n\n        listeners.push(\n          d.addEventListener(element, \"transitionend\", (event) => {\n            if (event.target !== event.currentTarget) return\n            onDone(\"ended\")\n            listeners.splice(0).forEach((d) => d())\n          }),\n          d.addEventListener(element, \"transitioncancel\", (event) => {\n            if (event.target !== event.currentTarget) return\n            onDone(\"canceled\")\n            listeners.splice(0).forEach((d) => d())\n          })\n        )\n      })\n    )\n  }\n\n  d.add(() => onDone(\"canceled\"))\n\n  return d.dispose\n}\n\nexport const doTransition = (\n  element: HTMLElement,\n  stage: TransitionStage,\n  classes: TransitionClasses,\n  callbacks: {\n    onStart?: (stage: TransitionStage) => void\n    onDone?: (stage: TransitionStage, status: TransitionStatus) => void\n  }\n) => {\n  let base: string[]\n  let from: string[]\n  let to: string[]\n  switch (stage) {\n    case \"enter\":\n      base = classes.enter\n      from = classes.enterFrom\n      to = classes.enterTo\n      break\n    case \"leave\":\n      base = classes.leave\n      from = classes.leaveFrom\n      to = classes.leaveTo\n      break\n  }\n\n  callbacks.onStart?.(stage)\n\n  element.classList.add(...base, ...from)\n\n  const d = new Disposables()\n  d.nextFrame(() => {\n    element.classList.remove(...from)\n    element.classList.add(...to)\n\n    waitForTransition(element, (status) => {\n      if (status === \"ended\") {\n        element.classList.remove(...base)\n      }\n      callbacks.onDone?.(stage, status)\n    })\n  })\n\n  return d.dispose\n}\n\nexport const transitionElement = (element: HTMLElement, stage: TransitionStage) =>\n  new Promise<TransitionStatus | undefined>((resolve) => {\n    if (!element.hasAttribute(\"data-transition\")) {\n      resolve(undefined)\n      return\n    }\n\n    const classes = getTransitionClasses(element)\n    doTransition(element, stage, classes, {\n      onDone: (_stage, status) => resolve(status)\n    })\n  })\n", "import { query } from \"../internal/decorators\"\nimport Modal from \"../internal/modal\"\nimport SproutElement from \"../internal/sprout-element\"\nimport { transitionElement } from \"../internal/transition\"\nimport type { SproutComponentSetup } from \"../types\"\nimport { isTruthy } from \"../utils\"\n\nclass DialogElement extends SproutElement {\n  @query(\"container\")\n  dialog: HTMLElement\n  @query(\"backdrop\")\n  backdrop: HTMLElement\n  @query(\"panel\")\n  panel: HTMLElement\n\n  private modal: Modal\n\n  static get observedAttributes() {\n    return [\"data-state\"]\n  }\n\n  connectedCallback() {\n    if (!this.dialog || !this.backdrop || !this.panel)\n      throw new Error(\"Dialog must have a backdrop element and a panel element.\")\n\n    this.modal = new Modal(this.panel, {\n      preventScroll: isTruthy(this.dataset.preventScroll),\n      dismissOnEsc: isTruthy(this.dataset.closeOnEsc),\n      dismissOnClickAway: isTruthy(this.dataset.closeOnClickAway)\n    })\n  }\n\n  updatedCallback(attribute: string, _oldValue: unknown, _newValue: unknown) {\n    if (attribute === \"data-state\") this.handleStateChange()\n  }\n\n  async handleStateChange() {\n    const parts = [this.backdrop, this.panel]\n\n    if (this.state === \"open\") {\n      this.executeJs(this, this.dataset.onOpenJs)\n\n      this.removeAttributeLive(this.dialog, \"hidden\")\n      this.modal.addEventListeners(() => {\n        this.setStateLive(\"closed\")\n      })\n      this.modal.activate()\n\n      await Promise.all(parts.map((part) => transitionElement(part, \"enter\")))\n    } else {\n      this.executeJs(this, this.dataset.onCloseJs)\n\n      this.modal.removeEventListeners()\n      this.modal.deactivate()\n      await Promise.all(parts.map((part) => transitionElement(part, \"leave\")))\n      this.setAttributeLive(this.dialog, \"hidden\", \"true\")\n    }\n  }\n}\n\nconst dialog: SproutComponentSetup = (_opts) => ({\n  init: () => {\n    customElements.define(\"sp-dialog\", DialogElement)\n  }\n})\n\nexport default dialog\n", "function t(t){return t.split(\"-\")[0]}function e(t){return t.split(\"-\")[1]}function n(e){return[\"top\",\"bottom\"].includes(t(e))?\"x\":\"y\"}function r(t){return\"y\"===t?\"height\":\"width\"}function i(i,o,a){let{reference:l,floating:s}=i;const c=l.x+l.width/2-s.width/2,f=l.y+l.height/2-s.height/2,u=n(o),m=r(u),g=l[m]/2-s[m]/2,d=\"x\"===u;let p;switch(t(o)){case\"top\":p={x:c,y:l.y-s.height};break;case\"bottom\":p={x:c,y:l.y+l.height};break;case\"right\":p={x:l.x+l.width,y:f};break;case\"left\":p={x:l.x-s.width,y:f};break;default:p={x:l.x,y:l.y}}switch(e(o)){case\"start\":p[u]-=g*(a&&d?-1:1);break;case\"end\":p[u]+=g*(a&&d?-1:1)}return p}const o=async(t,e,n)=>{const{placement:r=\"bottom\",strategy:o=\"absolute\",middleware:a=[],platform:l}=n,s=await(null==l.isRTL?void 0:l.isRTL(e));let c=await l.getElementRects({reference:t,floating:e,strategy:o}),{x:f,y:u}=i(c,r,s),m=r,g={},d=0;for(let n=0;n<a.length;n++){const{name:p,fn:h}=a[n],{x:y,y:x,data:w,reset:v}=await h({x:f,y:u,initialPlacement:r,placement:m,strategy:o,middlewareData:g,rects:c,platform:l,elements:{reference:t,floating:e}});f=null!=y?y:f,u=null!=x?x:u,g={...g,[p]:{...g[p],...w}},v&&d<=50&&(d++,\"object\"==typeof v&&(v.placement&&(m=v.placement),v.rects&&(c=!0===v.rects?await l.getElementRects({reference:t,floating:e,strategy:o}):v.rects),({x:f,y:u}=i(c,m,s))),n=-1)}return{x:f,y:u,placement:m,strategy:o,middlewareData:g}};function a(t){return\"number\"!=typeof t?function(t){return{top:0,right:0,bottom:0,left:0,...t}}(t):{top:t,right:t,bottom:t,left:t}}function l(t){return{...t,top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height}}async function s(t,e){var n;void 0===e&&(e={});const{x:r,y:i,platform:o,rects:s,elements:c,strategy:f}=t,{boundary:u=\"clippingAncestors\",rootBoundary:m=\"viewport\",elementContext:g=\"floating\",altBoundary:d=!1,padding:p=0}=e,h=a(p),y=c[d?\"floating\"===g?\"reference\":\"floating\":g],x=l(await o.getClippingRect({element:null==(n=await(null==o.isElement?void 0:o.isElement(y)))||n?y:y.contextElement||await(null==o.getDocumentElement?void 0:o.getDocumentElement(c.floating)),boundary:u,rootBoundary:m,strategy:f})),w=l(o.convertOffsetParentRelativeRectToViewportRelativeRect?await o.convertOffsetParentRelativeRectToViewportRelativeRect({rect:\"floating\"===g?{...s.floating,x:r,y:i}:s.reference,offsetParent:await(null==o.getOffsetParent?void 0:o.getOffsetParent(c.floating)),strategy:f}):s[g]);return{top:x.top-w.top+h.top,bottom:w.bottom-x.bottom+h.bottom,left:x.left-w.left+h.left,right:w.right-x.right+h.right}}const c=Math.min,f=Math.max;function u(t,e,n){return f(t,c(e,n))}const m=t=>({name:\"arrow\",options:t,async fn(i){const{element:o,padding:l=0}=null!=t?t:{},{x:s,y:c,placement:f,rects:m,platform:g}=i;if(null==o)return{};const d=a(l),p={x:s,y:c},h=n(f),y=e(f),x=r(h),w=await g.getDimensions(o),v=\"y\"===h?\"top\":\"left\",b=\"y\"===h?\"bottom\":\"right\",R=m.reference[x]+m.reference[h]-p[h]-m.floating[x],A=p[h]-m.reference[h],P=await(null==g.getOffsetParent?void 0:g.getOffsetParent(o));let T=P?\"y\"===h?P.clientHeight||0:P.clientWidth||0:0;0===T&&(T=m.floating[x]);const O=R/2-A/2,L=d[v],D=T-w[x]-d[b],k=T/2-w[x]/2+O,E=u(L,k,D),C=(\"start\"===y?d[v]:d[b])>0&&k!==E&&m.reference[x]<=m.floating[x];return{[h]:p[h]-(C?k<L?L-k:D-k:0),data:{[h]:E,centerOffset:k-E}}}}),g={left:\"right\",right:\"left\",bottom:\"top\",top:\"bottom\"};function d(t){return t.replace(/left|right|bottom|top/g,(t=>g[t]))}function p(t,i,o){void 0===o&&(o=!1);const a=e(t),l=n(t),s=r(l);let c=\"x\"===l?a===(o?\"end\":\"start\")?\"right\":\"left\":\"start\"===a?\"bottom\":\"top\";return i.reference[s]>i.floating[s]&&(c=d(c)),{main:c,cross:d(c)}}const h={start:\"end\",end:\"start\"};function y(t){return t.replace(/start|end/g,(t=>h[t]))}const x=[\"top\",\"right\",\"bottom\",\"left\"],w=x.reduce(((t,e)=>t.concat(e,e+\"-start\",e+\"-end\")),[]);const v=function(n){return void 0===n&&(n={}),{name:\"autoPlacement\",options:n,async fn(r){var i,o,a,l,c;const{x:f,y:u,rects:m,middlewareData:g,placement:d,platform:h,elements:x}=r,{alignment:v=null,allowedPlacements:b=w,autoAlignment:R=!0,...A}=n,P=function(n,r,i){return(n?[...i.filter((t=>e(t)===n)),...i.filter((t=>e(t)!==n))]:i.filter((e=>t(e)===e))).filter((t=>!n||e(t)===n||!!r&&y(t)!==t))}(v,R,b),T=await s(r,A),O=null!=(i=null==(o=g.autoPlacement)?void 0:o.index)?i:0,L=P[O];if(null==L)return{};const{main:D,cross:k}=p(L,m,await(null==h.isRTL?void 0:h.isRTL(x.floating)));if(d!==L)return{x:f,y:u,reset:{placement:P[0]}};const E=[T[t(L)],T[D],T[k]],C=[...null!=(a=null==(l=g.autoPlacement)?void 0:l.overflows)?a:[],{placement:L,overflows:E}],H=P[O+1];if(H)return{data:{index:O+1,overflows:C},reset:{placement:H}};const B=C.slice().sort(((t,e)=>t.overflows[0]-e.overflows[0])),V=null==(c=B.find((t=>{let{overflows:e}=t;return e.every((t=>t<=0))})))?void 0:c.placement,F=null!=V?V:B[0].placement;return F!==d?{data:{index:O+1,overflows:C},reset:{placement:F}}:{}}}};const b=function(e){return void 0===e&&(e={}),{name:\"flip\",options:e,async fn(n){var r;const{placement:i,middlewareData:o,rects:a,initialPlacement:l,platform:c,elements:f}=n,{mainAxis:u=!0,crossAxis:m=!0,fallbackPlacements:g,fallbackStrategy:h=\"bestFit\",flipAlignment:x=!0,...w}=e,v=t(i),b=g||(v===l||!x?[d(l)]:function(t){const e=d(t);return[y(t),e,y(e)]}(l)),R=[l,...b],A=await s(n,w),P=[];let T=(null==(r=o.flip)?void 0:r.overflows)||[];if(u&&P.push(A[v]),m){const{main:t,cross:e}=p(i,a,await(null==c.isRTL?void 0:c.isRTL(f.floating)));P.push(A[t],A[e])}if(T=[...T,{placement:i,overflows:P}],!P.every((t=>t<=0))){var O,L;const t=(null!=(O=null==(L=o.flip)?void 0:L.index)?O:0)+1,e=R[t];if(e)return{data:{index:t,overflows:T},reset:{placement:e}};let n=\"bottom\";switch(h){case\"bestFit\":{var D;const t=null==(D=T.map((t=>[t,t.overflows.filter((t=>t>0)).reduce(((t,e)=>t+e),0)])).sort(((t,e)=>t[1]-e[1]))[0])?void 0:D[0].placement;t&&(n=t);break}case\"initialPlacement\":n=l}if(i!==n)return{reset:{placement:n}}}return{}}}};function R(t,e){return{top:t.top-e.height,right:t.right-e.width,bottom:t.bottom-e.height,left:t.left-e.width}}function A(t){return x.some((e=>t[e]>=0))}const P=function(t){let{strategy:e=\"referenceHidden\",...n}=void 0===t?{}:t;return{name:\"hide\",async fn(t){const{rects:r}=t;switch(e){case\"referenceHidden\":{const e=R(await s(t,{...n,elementContext:\"reference\"}),r.reference);return{data:{referenceHiddenOffsets:e,referenceHidden:A(e)}}}case\"escaped\":{const e=R(await s(t,{...n,altBoundary:!0}),r.floating);return{data:{escapedOffsets:e,escaped:A(e)}}}default:return{}}}}};const T=function(r){return void 0===r&&(r=0),{name:\"offset\",options:r,async fn(i){const{x:o,y:a}=i,l=await async function(r,i){const{placement:o,platform:a,elements:l}=r,s=await(null==a.isRTL?void 0:a.isRTL(l.floating)),c=t(o),f=e(o),u=\"x\"===n(o),m=[\"left\",\"top\"].includes(c)?-1:1,g=s&&u?-1:1,d=\"function\"==typeof i?i(r):i;let{mainAxis:p,crossAxis:h,alignmentAxis:y}=\"number\"==typeof d?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...d};return f&&\"number\"==typeof y&&(h=\"end\"===f?-1*y:y),u?{x:h*g,y:p*m}:{x:p*m,y:h*g}}(i,r);return{x:o+l.x,y:a+l.y,data:l}}}};function O(t){return\"x\"===t?\"y\":\"x\"}const L=function(e){return void 0===e&&(e={}),{name:\"shift\",options:e,async fn(r){const{x:i,y:o,placement:a}=r,{mainAxis:l=!0,crossAxis:c=!1,limiter:f={fn:t=>{let{x:e,y:n}=t;return{x:e,y:n}}},...m}=e,g={x:i,y:o},d=await s(r,m),p=n(t(a)),h=O(p);let y=g[p],x=g[h];if(l){const t=\"y\"===p?\"bottom\":\"right\";y=u(y+d[\"y\"===p?\"top\":\"left\"],y,y-d[t])}if(c){const t=\"y\"===h?\"bottom\":\"right\";x=u(x+d[\"y\"===h?\"top\":\"left\"],x,x-d[t])}const w=f.fn({...r,[p]:y,[h]:x});return{...w,data:{x:w.x-i,y:w.y-o}}}}},D=function(e){return void 0===e&&(e={}),{options:e,fn(r){const{x:i,y:o,placement:a,rects:l,middlewareData:s}=r,{offset:c=0,mainAxis:f=!0,crossAxis:u=!0}=e,m={x:i,y:o},g=n(a),d=O(g);let p=m[g],h=m[d];const y=\"function\"==typeof c?c(r):c,x=\"number\"==typeof y?{mainAxis:y,crossAxis:0}:{mainAxis:0,crossAxis:0,...y};if(f){const t=\"y\"===g?\"height\":\"width\",e=l.reference[g]-l.floating[t]+x.mainAxis,n=l.reference[g]+l.reference[t]-x.mainAxis;p<e?p=e:p>n&&(p=n)}if(u){var w,v,b,R;const e=\"y\"===g?\"width\":\"height\",n=[\"top\",\"left\"].includes(t(a)),r=l.reference[d]-l.floating[e]+(n&&null!=(w=null==(v=s.offset)?void 0:v[d])?w:0)+(n?0:x.crossAxis),i=l.reference[d]+l.reference[e]+(n?0:null!=(b=null==(R=s.offset)?void 0:R[d])?b:0)-(n?x.crossAxis:0);h<r?h=r:h>i&&(h=i)}return{[g]:p,[d]:h}}}},k=function(n){return void 0===n&&(n={}),{name:\"size\",options:n,async fn(r){const{placement:i,rects:o,platform:a,elements:l}=r,{apply:c=(()=>{}),...u}=n,m=await s(r,u),g=t(i),d=e(i);let p,h;\"top\"===g||\"bottom\"===g?(p=g,h=d===(await(null==a.isRTL?void 0:a.isRTL(l.floating))?\"start\":\"end\")?\"left\":\"right\"):(h=g,p=\"end\"===d?\"top\":\"bottom\");const y=f(m.left,0),x=f(m.right,0),w=f(m.top,0),v=f(m.bottom,0),b={availableHeight:o.floating.height-([\"left\",\"right\"].includes(i)?2*(0!==w||0!==v?w+v:f(m.top,m.bottom)):m[p]),availableWidth:o.floating.width-([\"top\",\"bottom\"].includes(i)?2*(0!==y||0!==x?y+x:f(m.left,m.right)):m[h])};await c({...r,...b});const R=await a.getDimensions(l.floating);return o.floating.width!==R.width||o.floating.height!==R.height?{reset:{rects:!0}}:{}}}},E=function(e){return void 0===e&&(e={}),{name:\"inline\",options:e,async fn(r){var i;const{placement:o,elements:s,rects:u,platform:m,strategy:g}=r,{padding:d=2,x:p,y:h}=e,y=l(m.convertOffsetParentRelativeRectToViewportRelativeRect?await m.convertOffsetParentRelativeRectToViewportRelativeRect({rect:u.reference,offsetParent:await(null==m.getOffsetParent?void 0:m.getOffsetParent(s.floating)),strategy:g}):u.reference),x=null!=(i=await(null==m.getClientRects?void 0:m.getClientRects(s.reference)))?i:[],w=a(d);const v=await m.getElementRects({reference:{getBoundingClientRect:function(){var e;if(2===x.length&&x[0].left>x[1].right&&null!=p&&null!=h)return null!=(e=x.find((t=>p>t.left-w.left&&p<t.right+w.right&&h>t.top-w.top&&h<t.bottom+w.bottom)))?e:y;if(x.length>=2){if(\"x\"===n(o)){const e=x[0],n=x[x.length-1],r=\"top\"===t(o),i=e.top,a=n.bottom,l=r?e.left:n.left,s=r?e.right:n.right;return{top:i,bottom:a,left:l,right:s,width:s-l,height:a-i,x:l,y:i}}const e=\"left\"===t(o),r=f(...x.map((t=>t.right))),i=c(...x.map((t=>t.left))),a=x.filter((t=>e?t.left===i:t.right===r)),l=a[0].top,s=a[a.length-1].bottom;return{top:l,bottom:s,left:i,right:r,width:r-i,height:s-l,x:i,y:l}}return y}},floating:s.floating,strategy:g});return u.reference.x!==v.reference.x||u.reference.y!==v.reference.y||u.reference.width!==v.reference.width||u.reference.height!==v.reference.height?{reset:{rects:v}}:{}}}};export{m as arrow,v as autoPlacement,o as computePosition,s as detectOverflow,b as flip,P as hide,E as inline,D as limitShift,T as offset,l as rectToClientRect,L as shift,k as size};\n", "import{rectToClientRect as t,computePosition as e}from\"@floating-ui/core\";export{arrow,autoPlacement,detectOverflow,flip,hide,inline,limitShift,offset,shift,size}from\"@floating-ui/core\";function n(t){return t&&t.document&&t.location&&t.alert&&t.setInterval}function o(t){if(null==t)return window;if(!n(t)){const e=t.ownerDocument;return e&&e.defaultView||window}return t}function i(t){return o(t).getComputedStyle(t)}function r(t){return n(t)?\"\":t?(t.nodeName||\"\").toLowerCase():\"\"}function l(){const t=navigator.userAgentData;return null!=t&&t.brands?t.brands.map((t=>t.brand+\"/\"+t.version)).join(\" \"):navigator.userAgent}function c(t){return t instanceof o(t).HTMLElement}function s(t){return t instanceof o(t).Element}function f(t){if(\"undefined\"==typeof ShadowRoot)return!1;return t instanceof o(t).ShadowRoot||t instanceof ShadowRoot}function u(t){const{overflow:e,overflowX:n,overflowY:o,display:r}=i(t);return/auto|scroll|overlay|hidden/.test(e+o+n)&&![\"inline\",\"contents\"].includes(r)}function d(t){return[\"table\",\"td\",\"th\"].includes(r(t))}function h(t){const e=/firefox/i.test(l()),n=i(t);return\"none\"!==n.transform||\"none\"!==n.perspective||e&&\"filter\"===n.willChange||e&&!!n.filter&&\"none\"!==n.filter||[\"transform\",\"perspective\"].some((t=>n.willChange.includes(t)))||[\"paint\",\"layout\",\"strict\",\"content\"].some((t=>{const e=n.contain;return null!=e&&e.includes(t)}))}function a(){return!/^((?!chrome|android).)*safari/i.test(l())}function g(t){return[\"html\",\"body\",\"#document\"].includes(r(t))}const m=Math.min,p=Math.max,w=Math.round;function v(t,e,n){var i,r,l,f;void 0===e&&(e=!1),void 0===n&&(n=!1);const u=t.getBoundingClientRect();let d=1,h=1;e&&c(t)&&(d=t.offsetWidth>0&&w(u.width)/t.offsetWidth||1,h=t.offsetHeight>0&&w(u.height)/t.offsetHeight||1);const g=s(t)?o(t):window,m=!a()&&n,p=(u.left+(m&&null!=(i=null==(r=g.visualViewport)?void 0:r.offsetLeft)?i:0))/d,v=(u.top+(m&&null!=(l=null==(f=g.visualViewport)?void 0:f.offsetTop)?l:0))/h,y=u.width/d,x=u.height/h;return{width:y,height:x,top:v,right:p+y,bottom:v+x,left:p,x:p,y:v}}function y(t){return(e=t,(e instanceof o(e).Node?t.ownerDocument:t.document)||window.document).documentElement;var e}function x(t){return s(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function b(t){return v(y(t)).left+x(t).scrollLeft}function L(t,e,n){const o=c(e),i=y(e),l=v(t,o&&function(t){const e=v(t);return w(e.width)!==t.offsetWidth||w(e.height)!==t.offsetHeight}(e),\"fixed\"===n);let s={scrollLeft:0,scrollTop:0};const f={x:0,y:0};if(o||!o&&\"fixed\"!==n)if((\"body\"!==r(e)||u(i))&&(s=x(e)),c(e)){const t=v(e,!0);f.x=t.x+e.clientLeft,f.y=t.y+e.clientTop}else i&&(f.x=b(i));return{x:l.left+s.scrollLeft-f.x,y:l.top+s.scrollTop-f.y,width:l.width,height:l.height}}function R(t){return\"html\"===r(t)?t:t.assignedSlot||t.parentNode||(f(t)?t.host:null)||y(t)}function E(t){return c(t)&&\"fixed\"!==i(t).position?t.offsetParent:null}function T(t){const e=o(t);let n=E(t);for(;n&&d(n)&&\"static\"===i(n).position;)n=E(n);return n&&(\"html\"===r(n)||\"body\"===r(n)&&\"static\"===i(n).position&&!h(n))?e:n||function(t){let e=R(t);for(f(e)&&(e=e.host);c(e)&&!g(e);){if(h(e))return e;{const t=e.parentNode;e=f(t)?t.host:t}}return null}(t)||e}function W(t){if(c(t))return{width:t.offsetWidth,height:t.offsetHeight};const e=v(t);return{width:e.width,height:e.height}}function H(t){const e=R(t);return g(e)?t.ownerDocument.body:c(e)&&u(e)?e:H(e)}function C(t,e){var n;void 0===e&&(e=[]);const i=H(t),r=i===(null==(n=t.ownerDocument)?void 0:n.body),l=o(i),c=r?[l].concat(l.visualViewport||[],u(i)?i:[]):i,s=e.concat(c);return r?s:s.concat(C(c))}function D(e,n,r){return\"viewport\"===n?t(function(t,e){const n=o(t),i=y(t),r=n.visualViewport;let l=i.clientWidth,c=i.clientHeight,s=0,f=0;if(r){l=r.width,c=r.height;const t=a();(t||!t&&\"fixed\"===e)&&(s=r.offsetLeft,f=r.offsetTop)}return{width:l,height:c,x:s,y:f}}(e,r)):s(n)?function(t,e){const n=v(t,!1,\"fixed\"===e),o=n.top+t.clientTop,i=n.left+t.clientLeft;return{top:o,left:i,x:i,y:o,right:i+t.clientWidth,bottom:o+t.clientHeight,width:t.clientWidth,height:t.clientHeight}}(n,r):t(function(t){var e;const n=y(t),o=x(t),r=null==(e=t.ownerDocument)?void 0:e.body,l=p(n.scrollWidth,n.clientWidth,r?r.scrollWidth:0,r?r.clientWidth:0),c=p(n.scrollHeight,n.clientHeight,r?r.scrollHeight:0,r?r.clientHeight:0);let s=-o.scrollLeft+b(t);const f=-o.scrollTop;return\"rtl\"===i(r||n).direction&&(s+=p(n.clientWidth,r?r.clientWidth:0)-l),{width:l,height:c,x:s,y:f}}(y(e)))}function N(t){const e=C(t),n=function(t,e){let n=t;for(;n&&!g(n)&&!e.includes(n)&&(!s(n)||![\"absolute\",\"fixed\"].includes(i(n).position));){const t=R(n);n=f(t)?t.host:t}return n}(t,e);let o=null;if(n&&c(n)){const t=T(n);u(n)?o=n:c(t)&&(o=t)}return s(o)?e.filter((t=>o&&s(t)&&function(t,e){const n=null==e.getRootNode?void 0:e.getRootNode();if(t.contains(e))return!0;if(n&&f(n)){let n=e;do{if(n&&t===n)return!0;n=n.parentNode||n.host}while(n)}return!1}(t,o)&&\"body\"!==r(t))):[]}const S={getClippingRect:function(t){let{element:e,boundary:n,rootBoundary:o,strategy:i}=t;const r=[...\"clippingAncestors\"===n?N(e):[].concat(n),o],l=r[0],c=r.reduce(((t,n)=>{const o=D(e,n,i);return t.top=p(o.top,t.top),t.right=m(o.right,t.right),t.bottom=m(o.bottom,t.bottom),t.left=p(o.left,t.left),t}),D(e,l,i));return{width:c.right-c.left,height:c.bottom-c.top,x:c.left,y:c.top}},convertOffsetParentRelativeRectToViewportRelativeRect:function(t){let{rect:e,offsetParent:n,strategy:o}=t;const i=c(n),l=y(n);if(n===l)return e;let s={scrollLeft:0,scrollTop:0};const f={x:0,y:0};if((i||!i&&\"fixed\"!==o)&&((\"body\"!==r(n)||u(l))&&(s=x(n)),c(n))){const t=v(n,!0);f.x=t.x+n.clientLeft,f.y=t.y+n.clientTop}return{...e,x:e.x-s.scrollLeft+f.x,y:e.y-s.scrollTop+f.y}},isElement:s,getDimensions:W,getOffsetParent:T,getDocumentElement:y,getElementRects:t=>{let{reference:e,floating:n,strategy:o}=t;return{reference:L(e,T(n),o),floating:{...W(n),x:0,y:0}}},getClientRects:t=>Array.from(t.getClientRects()),isRTL:t=>\"rtl\"===i(t).direction};function z(t,e,n,o){void 0===o&&(o={});const{ancestorScroll:i=!0,ancestorResize:r=!0,elementResize:l=!0,animationFrame:c=!1}=o,f=i&&!c,u=f||r?[...s(t)?C(t):t.contextElement?C(t.contextElement):[],...C(e)]:[];u.forEach((t=>{f&&t.addEventListener(\"scroll\",n,{passive:!0}),r&&t.addEventListener(\"resize\",n)}));let d,h=null;if(l){let o=!0;h=new ResizeObserver((()=>{o||n(),o=!1})),s(t)&&!c&&h.observe(t),s(t)||!t.contextElement||c||h.observe(t.contextElement),h.observe(e)}let a=c?v(t):null;return c&&function e(){const o=v(t);!a||o.x===a.x&&o.y===a.y&&o.width===a.width&&o.height===a.height||n();a=o,d=requestAnimationFrame(e)}(),n(),()=>{var t;u.forEach((t=>{f&&t.removeEventListener(\"scroll\",n),r&&t.removeEventListener(\"resize\",n)})),null==(t=h)||t.disconnect(),h=null,c&&cancelAnimationFrame(d)}}const A=(t,n,o)=>e(t,n,{platform:S,...o});export{z as autoUpdate,A as computePosition,C as getOverflowAncestors,S as platform};\n", "import {\n  arrow,\n  autoUpdate,\n  computePosition,\n  flip,\n  Middleware,\n  offset,\n  Placement,\n  shift\n} from \"@floating-ui/dom\"\nimport { attr, query } from \"../internal/decorators\"\nimport { SproutComponentSetup } from \"../types\"\nimport { isTruthy, isVisible } from \"../utils\"\n\nclass FloatingElement extends HTMLDivElement {\n  anchor: HTMLElement\n  @query(\"arrow\")\n  arrow: HTMLElement | null\n\n  @attr(\"data-placement\")\n  placement: Placement\n  @attr(\"data-offset\", Number)\n  offset: number\n  @attr(\"data-shift\", isTruthy)\n  shift: boolean\n  @attr(\"data-flip\", isTruthy)\n  flip: boolean\n\n  private middleware: Middleware[]\n  private cleanup: ReturnType<typeof autoUpdate> | undefined\n\n  connectedCallback() {\n    const anchor = document.querySelector<HTMLElement>(this.dataset.anchor!)\n    if (!anchor) throw new Error(\"Floating element must have an anchor element\")\n\n    this.anchor = anchor\n    this.middleware = this.buildMiddleware()\n    this.start()\n  }\n\n  disconnectedCallback() {\n    this.cleanup?.()\n  }\n\n  private buildMiddleware() {\n    const middleware: Middleware[] = []\n    if (this.offset) middleware.push(offset(this.offset))\n    if (this.shift) middleware.push(shift({ rootBoundary: \"document\" }))\n    if (this.flip) middleware.push(flip())\n    if (this.arrow) middleware.push(arrow({ element: this.arrow }))\n    return middleware\n  }\n\n  start() {\n    this.cleanup = autoUpdate(this.anchor, this, this.update.bind(this))\n  }\n\n  update() {\n    if (!isVisible(this)) return\n    computePosition(this.anchor, this, {\n      placement: this.placement,\n      middleware: this.middleware\n    }).then(({ x, y, placement, middlewareData }) => {\n      Object.assign(this.style, {\n        left: `${x}px`,\n        top: `${y}px`\n      })\n\n      if (middlewareData.arrow && this.arrow) {\n        const { x: arrowX, y: arrowY } = middlewareData.arrow\n\n        const staticSide = {\n          top: \"bottom\",\n          right: \"left\",\n          bottom: \"top\",\n          left: \"right\"\n        }[placement.split(\"-\")[0]] as string\n\n        Object.assign(this.arrow.style, {\n          left: arrowX != null ? `${arrowX}px` : \"\",\n          top: arrowY != null ? `${arrowY}px` : \"\",\n          right: \"\",\n          bottom: \"\",\n          [staticSide]: \"-4px\"\n        })\n      }\n    })\n  }\n}\n\nconst floating: SproutComponentSetup = () => ({\n  init: () => {\n    customElements.define(\"floating-element\", FloatingElement, { extends: \"div\" })\n  },\n  handleDomChange: (from, to) => {\n    if (from.getAttribute(\"is\") === \"floating-element\") {\n      to.setAttribute(\"style\", from.getAttribute(\"style\")!)\n    }\n  }\n})\n\nexport default floating\n", "import { query } from \"../internal/decorators\"\nimport Modal from \"../internal/modal\"\nimport SproutElement from \"../internal/sprout-element\"\nimport { transitionElement } from \"../internal/transition\"\nimport { SproutComponentSetup } from \"../types\"\nimport { flipping, isTruthy } from \"../utils\"\nimport Disposables from \"../utils/disposables\"\n\nclass PopoverElement extends SproutElement {\n  @query(\"trigger\")\n  trigger: HTMLElement\n  @query(\"panel\")\n  panel: HTMLElement\n\n  private modal: Modal\n  private listeners = new Disposables()\n\n  static get observedAttributes() {\n    return [\"data-state\"]\n  }\n\n  connectedCallback() {\n    if (!this.panel || !this.trigger)\n      throw new Error(\"Popover must have a trigger element and a panel element.\")\n\n    this.listeners.addEventListener(this.trigger, \"click\", () => {\n      this.setStateLive(flipping(this.state))\n    })\n\n    this.modal = new Modal(this.panel, {\n      preventScroll: false,\n      dismissOnEsc: isTruthy(this.dataset.closeOnEsc),\n      dismissOnClickAway: isTruthy(this.dataset.closeOnClickAway)\n    })\n  }\n\n  updatedCallback(attribute: string, _oldValue: unknown, _newValue: unknown) {\n    if (attribute === \"data-state\") this.handleStateChange()\n  }\n\n  disconnectedCallback() {\n    this.listeners.dispose()\n  }\n\n  async handleStateChange() {\n    if (this.state === \"open\") {\n      this.executeJs(this, this.dataset.onOpenJs)\n\n      this.modal.addEventListeners(() => {\n        this.setStateLive(\"closed\")\n      })\n\n      // `on-click-away` listener must be registered before panel is visible,\n      // or clicking on the trigger button will also trigger a `click-away` event\n      const d = new Disposables()\n      d.nextFrame(() => {\n        this.removeAttributeLive(this.panel, \"hidden\")\n        this.setAttributeLive(this.trigger, \"aria-expanded\", \"true\")\n        transitionElement(this.panel, \"enter\")\n      })\n    } else {\n      this.executeJs(this, this.dataset.onCloseJs)\n\n      this.modal.removeEventListeners()\n      await transitionElement(this.panel, \"leave\")\n      this.setAttributeLive(this.panel, \"hidden\", \"true\")\n      this.setAttributeLive(this.trigger, \"aria-expanded\", \"false\")\n    }\n  }\n}\n\nconst popover: SproutComponentSetup = () => ({\n  init: () => {\n    customElements.define(\"sp-popover\", PopoverElement)\n  }\n})\n\nexport default popover\n", "import { attr, query } from \"../internal/decorators\"\nimport SproutElement from \"../internal/sprout-element\"\nimport { transitionElement } from \"../internal/transition\"\nimport { SproutComponentSetup } from \"../types\"\nimport Disposables from \"../utils/disposables\"\n\nclass TooltipElement extends SproutElement {\n  @query(\"trigger\")\n  trigger: HTMLElement\n  @query(\"container\")\n  container: HTMLElement\n\n  @attr(\"data-open-delay\", Number)\n  openDelay: number\n  @attr(\"data-close-delay\", Number)\n  closeDelay: number\n\n  private disposables = new Disposables()\n  private listeners = new Disposables()\n\n  static get observedAttributes() {\n    return [\"data-state\"]\n  }\n\n  connectedCallback() {\n    if (!this.container || !this.trigger)\n      throw new Error(\"Tooltip must have a trigger element and a container element.\")\n\n    this.addEventListeners()\n  }\n\n  updatedCallback(attribute: string, _oldValue: unknown, _newValue: unknown) {\n    if (attribute === \"data-state\") this.handleStateChange()\n  }\n\n  disconnectedCallback() {\n    this.disposables.dispose()\n    this.removeEventListeners()\n  }\n\n  addEventListeners() {\n    this.listeners.addEventListener(this.trigger, \"mouseover\", () => {\n      this.disposables.dispose()\n      this.disposables.setTimeout(() => {\n        this.setStateLive(\"open\")\n      }, this.openDelay)\n    })\n    this.listeners.addEventListener(this.trigger, \"mouseout\", () => {\n      this.disposables.dispose()\n      this.disposables.setTimeout(() => {\n        this.setStateLive(\"closed\")\n      }, this.closeDelay)\n    })\n    this.listeners.addEventListener(this.trigger, \"focus\", () => {\n      this.disposables.dispose()\n      this.setStateLive(\"open\")\n    })\n    this.listeners.addEventListener(this.trigger, \"blur\", () => {\n      this.disposables.dispose()\n      this.setStateLive(\"closed\")\n    })\n    this.listeners.addEventListener(this.trigger, \"click\", () => {\n      this.disposables.dispose()\n      this.setStateLive(\"open\")\n    })\n    this.listeners.addEventListener(document, \"keydown\", (event) => {\n      const { key } = event as KeyboardEvent\n      if (this.state === \"open\" && key === \"Escape\") {\n        this.setStateLive(\"closed\")\n        event.stopPropagation()\n      }\n    })\n  }\n\n  removeEventListeners() {\n    this.listeners.dispose()\n  }\n\n  async handleStateChange() {\n    if (this.state === \"open\") {\n      this.executeJs(this, this.dataset.onOpenJs)\n\n      this.removeAttributeLive(this.container, \"hidden\")\n      transitionElement(this.container, \"enter\")\n    } else {\n      this.executeJs(this, this.dataset.onCloseJs)\n\n      await transitionElement(this.container, \"leave\")\n      this.setAttributeLive(this.container, \"hidden\", \"true\")\n    }\n  }\n}\n\nconst tooltip: SproutComponentSetup = () => ({\n  init: () => {\n    customElements.define(\"sp-tooltip\", TooltipElement)\n  }\n})\n\nexport default tooltip\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAM,mBAAmB,CAAC,UAAyB;AACxD,MAAI,CAAC;AAAO;AACZ,UAAQ,OAAO;AAAA,IACb,KAAK;AACH,aAAO,OAAO,SAAS,KAAK,OAAO,EAAE,UAAU,GAAG,CAAC;AACnD;AAAA,IACF,KAAK;AACH,aAAO,OAAO,SAAS,KAAK,OAAO,EAAE,UAAU,SAAS,CAAC;AACzD;AAAA,EACJ;AACF;;;ACJA,IAAM,OAAO,MAAM;AACjB,SAAO,iBAAiB,uBAAuB,CAACA,OAAM;AACpD,UAAM,EAAE,QAAQ,OAAO,IAAIA;AAC3B,UAAM,QACJ,OAAO,aAAa,OAAO,SAAS,MAAM,OAAO,OAAO,KACpD,OAAO,OAAO,KACd,OAAO,OAAO;AACpB,WAAO,aAAa,OAAO,WAAW,KAAK;AAAA,EAC7C,CAAC;AAED,SAAO,iBAAiB,yBAAyB,CAACA,OAAM;AACtD,UAAM,EAAE,OAAO,IAAIA;AACnB,qBAAiB,OAAO,KAAK;AAAA,EAC/B,CAAC;AACH;AAEA,IAAM,SAA+B,OAAO;AAAA,EAC1C;AACF;AAEA,IAAO,iBAAQ;;;AC1BR,IAAM,QAAQ,CAAC,SAAiB,CAAC,QAAqB,gBAAwB;AACnF,QAAM,MAAM,IAAI;AAChB,UAAQ,eAAe,QAAQ,aAAa;AAAA,IAC1C,MAAe;AACb,UAAI,KAAK,SAAS,QAAW;AAC3B,aAAK,OAAO,KAAK,cAAc,eAAe,QAAQ;AAAA,MACxD;AACA,aAAO,KAAK;AAAA,IACd;AAAA,IACA,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB,CAAC;AACH;AAEO,IAAM,OACX,CAAC,MAAc,cACb,CAAC,QAAqB,gBAAwB;AAC5C,UAAQ,eAAe,QAAQ,aAAa;AAAA,IAC1C,MAAuB;AACrB,YAAM,QAAQ,KAAK,aAAa,IAAI;AACpC,aAAO,CAAC,CAAC,YAAY,UAAU,KAAK,IAAI;AAAA,IAC1C;AAAA,IACA,IAAuB,OAAY;AACjC,WAAK,aAAa,MAAM,KAAK;AAAA,IAC/B;AAAA,IACA,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB,CAAC;AACH;;;AC5BJ,IAAMC,qBAAqB,CACzB,SACA,UACA,YACA,WACA,UACA,wBACA,mBACA,mBACA,oDACA,iCACA,SAAS;AAEX,IAAMC,oBAAoCD,mCAAmBE,KAAK,GAAG;AAErE,IAAMC,YAAY,OAAOC,YAAY;AAErC,IAAMC,UAAUF,YACZ,WAAY;AAAA,IACZC,QAAQE,UAAUD,WAClBD,QAAQE,UAAUC,qBAClBH,QAAQE,UAAUE;AAEtB,IAAMC,cACJ,CAACN,aAAaC,QAAQE,UAAUG,cAC5B,SAACC,SAAO;AAAA,SAAKA,QAAQD,YAAW;AAAE,IAClC,SAACC,SAAO;AAAA,SAAKA,QAAQC;AAAa;AAQxC,IAAMC,gBAAgB,SAAhBA,eAA0BC,IAAIC,kBAAkBC,QAAQ;AAC5D,MAAIC,aAAaC,MAAMX,UAAUY,MAAMC,MACrCN,GAAGO,iBAAiBnB,iBAAiB,CAAC;AAExC,MAAIa,oBAAoBT,QAAQgB,KAAKR,IAAIZ,iBAAiB,GAAG;AAC3De,eAAWM,QAAQT,EAAE;EACvB;AACAG,eAAaA,WAAWD,OAAOA,MAAM;AACrC,SAAOC;AACT;AAoCA,IAAMO,2BAA2B,SAA3BA,0BACJC,UACAV,kBACAW,SACA;AACA,MAAMT,aAAa,CAAA;AACnB,MAAMU,kBAAkBT,MAAMU,KAAKH,QAAQ;AAC3C,SAAOE,gBAAgBE,QAAQ;AAC7B,QAAMlB,UAAUgB,gBAAgBG,MAAK;AACrC,QAAInB,QAAQoB,YAAY,QAAQ;AAE9B,UAAMC,WAAWrB,QAAQsB,iBAAgB;AACzC,UAAMC,UAAUF,SAASH,SAASG,WAAWrB,QAAQwB;AACrD,UAAMC,mBAAmBZ,0BAAyBU,SAAS,MAAMR,OAAO;AACxE,UAAIA,QAAQW,SAAS;AACnBpB,mBAAWqB,KAAI,MAAfrB,YAAmBmB,gBAAgB;MACrC,OAAO;AACLnB,mBAAWqB,KAAK;UACdC,aAAa5B;UACbM,YAAYmB;QACd,CAAC;MACH;IACF,OAAO;AAEL,UAAMI,iBAAiBlC,QAAQgB,KAAKX,SAAST,iBAAiB;AAC9D,UACEsC,kBACAd,QAAQV,OAAOL,OAAO,MACrBI,oBAAoB,CAACU,SAASgB,SAAS9B,OAAO,IAC/C;AACAM,mBAAWqB,KAAK3B,OAAO;MACzB;AAGA,UAAM+B,aACJ/B,QAAQ+B,cAEP,OAAOhB,QAAQiB,kBAAkB,cAChCjB,QAAQiB,cAAchC,OAAO;AAEjC,UAAMiC,kBACJ,CAAClB,QAAQmB,oBAAoBnB,QAAQmB,iBAAiBlC,OAAO;AAE/D,UAAI+B,cAAcE,iBAAiB;AAOjC,YAAMR,oBAAmBZ,0BACvBkB,eAAe,OAAO/B,QAAQwB,WAAWO,WAAWP,UACpD,MACAT,OAAO;AAGT,YAAIA,QAAQW,SAAS;AACnBpB,qBAAWqB,KAAI,MAAfrB,YAAmBmB,iBAAgB;QACrC,OAAO;AACLnB,qBAAWqB,KAAK;YACdC,aAAa5B;YACbM,YAAYmB;UACd,CAAC;QACH;MACF,OAAO;AAGLT,wBAAgBJ,QAAhBI,MAAAA,iBAA2BhB,QAAQwB,QAAQ;MAC7C;IACF;EACF;AACA,SAAOlB;AACT;AAEA,IAAM6B,cAAc,SAAdA,aAAwBC,MAAMC,SAAS;AAC3C,MAAID,KAAKE,WAAW,GAAG;AAYrB,SACGD,WACC,0BAA0BE,KAAKH,KAAKhB,OAAO,KAC3CgB,KAAKI,sBACPC,MAAMC,SAASN,KAAKO,aAAa,UAAU,GAAG,EAAE,CAAC,GACjD;AACA,aAAO;IACT;EACF;AAEA,SAAOP,KAAKE;AACd;AAEA,IAAMM,uBAAuB,SAAvBA,sBAAiCC,IAAGC,IAAG;AAC3C,SAAOD,GAAEP,aAAaQ,GAAER,WACpBO,GAAEE,gBAAgBD,GAAEC,gBACpBF,GAAEP,WAAWQ,GAAER;AACrB;AAEA,IAAMU,UAAU,SAAVA,SAAoBZ,MAAM;AAC9B,SAAOA,KAAKhB,YAAY;AAC1B;AAEA,IAAM6B,gBAAgB,SAAhBA,eAA0Bb,MAAM;AACpC,SAAOY,QAAQZ,IAAI,KAAKA,KAAKc,SAAS;AACxC;AAEA,IAAMC,uBAAuB,SAAvBA,sBAAiCf,MAAM;AAC3C,MAAMgB,KACJhB,KAAKhB,YAAY,aACjBb,MAAMX,UAAUY,MACbC,MAAM2B,KAAKZ,QAAQ,EACnB6B,KAAK,SAACC,OAAK;AAAA,WAAKA,MAAMlC,YAAY;GAAU;AACjD,SAAOgC;AACT;AAEA,IAAMG,kBAAkB,SAAlBA,iBAA4BC,OAAOC,MAAM;AAC7C,WAASC,KAAI,GAAGA,KAAIF,MAAMtC,QAAQwC,MAAK;AACrC,QAAIF,MAAME,IAAGC,WAAWH,MAAME,IAAGD,SAASA,MAAM;AAC9C,aAAOD,MAAME;IACf;EACF;AACF;AAEA,IAAME,kBAAkB,SAAlBA,iBAA4BxB,MAAM;AACtC,MAAI,CAACA,KAAKyB,MAAM;AACd,WAAO;EACT;AACA,MAAMC,aAAa1B,KAAKqB,QAAQ1D,YAAYqC,IAAI;AAChD,MAAM2B,cAAc,SAAdA,aAAwBF,MAAM;AAClC,WAAOC,WAAWpD,iBAChB,+BAA+BmD,OAAO,IAAI;;AAI9C,MAAIG;AACJ,MACE,OAAOC,WAAW,eAClB,OAAOA,OAAOC,QAAQ,eACtB,OAAOD,OAAOC,IAAIC,WAAW,YAC7B;AACAH,eAAWD,YAAYE,OAAOC,IAAIC,OAAO/B,KAAKyB,IAAI,CAAC;EACrD,OAAO;AACL,QAAI;AACFG,iBAAWD,YAAY3B,KAAKyB,IAAI;aACzBO,KAAP;AAEAC,cAAQC,MACN,4IACAF,IAAIG,OAAO;AAEb,aAAO;IACT;EACF;AAEA,MAAMZ,UAAUJ,gBAAgBS,UAAU5B,KAAKqB,IAAI;AACnD,SAAO,CAACE,WAAWA,YAAYvB;AACjC;AAEA,IAAMoC,UAAU,SAAVA,SAAoBpC,MAAM;AAC9B,SAAOY,QAAQZ,IAAI,KAAKA,KAAKc,SAAS;AACxC;AAEA,IAAMuB,qBAAqB,SAArBA,oBAA+BrC,MAAM;AACzC,SAAOoC,QAAQpC,IAAI,KAAK,CAACwB,gBAAgBxB,IAAI;AAC/C;AAGA,IAAMsC,iBAAiB,SAAjBA,gBAA2BtC,MAAM;AAAA,MAAA;AAoBrC,MAAIuC,eAAe5E,YAAYqC,IAAI,EAAEwC;AACrC,MAAIC,WAAW,CAAC,GACd,gBAAAF,kBAAY,QAAA,kBAAA,UAAZ,cAAc1E,cAAc6E,SAASH,YAAY,KACjDvC,KAAKnC,cAAc6E,SAAS1C,IAAI;AAGlC,SAAO,CAACyC,YAAYF,cAAc;AAAA,QAAA;AAIhCA,mBAAe5E,YAAY4E,YAAY,EAAEC;AACzCC,eAAW,CAAC,GAAA,iBAACF,kBAAY,QAAA,mBAAA,UAAZ,eAAc1E,cAAc6E,SAASH,YAAY;EAChE;AAEA,SAAOE;AACT;AAEA,IAAME,aAAa,SAAbA,YAAuB3C,MAAM;AACjC,MAA0BA,wBAAAA,KAAK4C,sBAAqB,GAA5CC,QAAK,sBAALA,OAAOC,SAAM,sBAANA;AACf,SAAOD,UAAU,KAAKC,WAAW;AACnC;AACA,IAAMC,WAAW,SAAXA,UAAqB/C,MAAuC,MAAA;AAAA,MAA/BgD,eAAY,KAAZA,cAAcpD,gBAAa,KAAbA;AAM/C,MAAIqD,iBAAiBjD,IAAI,EAAEkD,eAAe,UAAU;AAClD,WAAO;EACT;AAEA,MAAMC,kBAAkB5F,QAAQgB,KAAKyB,MAAM,+BAA+B;AAC1E,MAAMoD,mBAAmBD,kBAAkBnD,KAAKqD,gBAAgBrD;AAChE,MAAIzC,QAAQgB,KAAK6E,kBAAkB,uBAAuB,GAAG;AAC3D,WAAO;EACT;AAEA,MACE,CAACJ,gBACDA,iBAAiB,UACjBA,iBAAiB,eACjB;AACA,QAAI,OAAOpD,kBAAkB,YAAY;AAGvC,UAAM0D,eAAetD;AACrB,aAAOA,MAAM;AACX,YAAMqD,gBAAgBrD,KAAKqD;AAC3B,YAAME,WAAW5F,YAAYqC,IAAI;AACjC,YACEqD,iBACA,CAACA,cAAc1D,cACfC,cAAcyD,aAAa,MAAM,MACjC;AAGA,iBAAOV,WAAW3C,IAAI;QACxB,WAAWA,KAAKwD,cAAc;AAE5BxD,iBAAOA,KAAKwD;mBACH,CAACH,iBAAiBE,aAAavD,KAAKnC,eAAe;AAE5DmC,iBAAOuD,SAASf;QAClB,OAAO;AAELxC,iBAAOqD;QACT;MACF;AAEArD,aAAOsD;IACT;AAWA,QAAIhB,eAAetC,IAAI,GAAG;AAKxB,aAAO,CAACA,KAAKyD,eAAc,EAAG3E;IAChC;AAkBA,QAAIkE,iBAAiB,eAAe;AAClC,aAAO;IACT;EAEF,WAAWA,iBAAiB,iBAAiB;AAM3C,WAAOL,WAAW3C,IAAI;EACxB;AAIA,SAAO;AACT;AAKA,IAAM0D,yBAAyB,SAAzBA,wBAAmC1D,MAAM;AAC7C,MAAI,mCAAmCG,KAAKH,KAAKhB,OAAO,GAAG;AACzD,QAAI2E,aAAa3D,KAAKqD;AAEtB,WAAOM,YAAY;AACjB,UAAIA,WAAW3E,YAAY,cAAc2E,WAAWC,UAAU;AAE5D,iBAAStC,KAAI,GAAGA,KAAIqC,WAAWvE,SAASN,QAAQwC,MAAK;AACnD,cAAMJ,QAAQyC,WAAWvE,SAASyE,KAAKvC,EAAC;AAExC,cAAIJ,MAAMlC,YAAY,UAAU;AAG9B,mBAAOzB,QAAQgB,KAAKoF,YAAY,sBAAsB,IAClD,OACA,CAACzC,MAAMwB,SAAS1C,IAAI;UAC1B;QACF;AAEA,eAAO;MACT;AACA2D,mBAAaA,WAAWN;IAC1B;EACF;AAIA,SAAO;AACT;AAEA,IAAMS,kCAAkC,SAAlCA,iCAA4CnF,SAASqB,MAAM;AAC/D,MACEA,KAAK4D,YACL/C,cAAcb,IAAI,KAClB+C,SAAS/C,MAAMrB,OAAO,KAEtBoC,qBAAqBf,IAAI,KACzB0D,uBAAuB1D,IAAI,GAC3B;AACA,WAAO;EACT;AACA,SAAO;AACT;AAEA,IAAM+D,iCAAiC,SAAjCA,gCAA2CpF,SAASqB,MAAM;AAC9D,MACEqC,mBAAmBrC,IAAI,KACvBD,YAAYC,IAAI,IAAI,KACpB,CAAC8D,gCAAgCnF,SAASqB,IAAI,GAC9C;AACA,WAAO;EACT;AACA,SAAO;AACT;AAEA,IAAMgE,4BAA4B,SAA5BA,2BAAsCC,gBAAgB;AAC1D,MAAM/D,WAAWI,SAAS2D,eAAe1D,aAAa,UAAU,GAAG,EAAE;AACrE,MAAIF,MAAMH,QAAQ,KAAKA,YAAY,GAAG;AACpC,WAAO;EACT;AAGA,SAAO;AACT;AAMA,IAAMgE,cAAc,SAAdA,aAAwBhG,YAAY;AACxC,MAAMiG,mBAAmB,CAAA;AACzB,MAAMC,mBAAmB,CAAA;AACzBlG,aAAWmG,QAAQ,SAAUR,MAAMvC,IAAG;AACpC,QAAMrB,UAAU,CAAC,CAAC4D,KAAKrE;AACvB,QAAM5B,UAAUqC,UAAU4D,KAAKrE,cAAcqE;AAC7C,QAAMS,oBAAoBvE,YAAYnC,SAASqC,OAAO;AACtD,QAAMvB,WAAWuB,UAAUiE,aAAYL,KAAK3F,UAAU,IAAIN;AAC1D,QAAI0G,sBAAsB,GAAG;AAC3BrE,gBACIkE,iBAAiB5E,KAAI,MAArB4E,kBAAyBzF,QAAQ,IACjCyF,iBAAiB5E,KAAK3B,OAAO;IACnC,OAAO;AACLwG,uBAAiB7E,KAAK;QACpBoB,eAAeW;QACfpB,UAAUoE;QACVT;QACA5D;QACAd,SAAST;MACX,CAAC;IACH;EACF,CAAC;AAED,SAAO0F,iBACJG,KAAK/D,oBAAoB,EACzBgE,OAAO,SAACC,KAAKC,UAAa;AACzBA,aAASzE,UACLwE,IAAIlF,KAAI,MAARkF,KAAYC,SAASvF,OAAO,IAC5BsF,IAAIlF,KAAKmF,SAASvF,OAAO;AAC7B,WAAOsF;EACT,GAAG,CAAA,CAAE,EACJE,OAAOR,gBAAgB;AAC5B;AAEMS,IAAAA,WAAW,SAAXA,UAAqB7G,IAAIY,SAAS;AACtCA,YAAUA,WAAW,CAAA;AAErB,MAAIT;AACJ,MAAIS,QAAQiB,eAAe;AACzB1B,iBAAaO,yBAAyB,CAACV,EAAE,GAAGY,QAAQX,kBAAkB;MACpEC,QAAQ8F,+BAA+Bc,KAAK,MAAMlG,OAAO;MACzDW,SAAS;MACTM,eAAejB,QAAQiB;MACvBE,kBAAkBkE;IACpB,CAAC;EACH,OAAO;AACL9F,iBAAaJ,cACXC,IACAY,QAAQX,kBACR+F,+BAA+Bc,KAAK,MAAMlG,OAAO,CAAC;EAEtD;AACA,SAAOuF,YAAYhG,UAAU;AAC/B;AAEM4G,IAAAA,YAAY,SAAZA,WAAsB/G,IAAIY,SAAS;AACvCA,YAAUA,WAAW,CAAA;AAErB,MAAIT;AACJ,MAAIS,QAAQiB,eAAe;AACzB1B,iBAAaO,yBAAyB,CAACV,EAAE,GAAGY,QAAQX,kBAAkB;MACpEC,QAAQ6F,gCAAgCe,KAAK,MAAMlG,OAAO;MAC1DW,SAAS;MACTM,eAAejB,QAAQiB;IACzB,CAAC;EACH,OAAO;AACL1B,iBAAaJ,cACXC,IACAY,QAAQX,kBACR8F,gCAAgCe,KAAK,MAAMlG,OAAO,CAAC;EAEvD;AAEA,SAAOT;AACT;AAEM6G,IAAAA,aAAa,SAAbA,YAAuB/E,MAAMrB,SAAS;AAC1CA,YAAUA,WAAW,CAAA;AACrB,MAAI,CAACqB,MAAM;AACT,UAAM,IAAIgF,MAAM,kBAAkB;EACpC;AACA,MAAIzH,QAAQgB,KAAKyB,MAAM7C,iBAAiB,MAAM,OAAO;AACnD,WAAO;EACT;AACA,SAAO4G,+BAA+BpF,SAASqB,IAAI;AACrD;AAEA,IAAMiF,6BAA6C/H,mCAChDyH,OAAO,QAAQ,EACfvH,KAAK,GAAG;AAEL8H,IAAAA,cAAc,SAAdA,aAAwBlF,MAAMrB,SAAS;AAC3CA,YAAUA,WAAW,CAAA;AACrB,MAAI,CAACqB,MAAM;AACT,UAAM,IAAIgF,MAAM,kBAAkB;EACpC;AACA,MAAIzH,QAAQgB,KAAKyB,MAAMiF,0BAA0B,MAAM,OAAO;AAC5D,WAAO;EACT;AACA,SAAOnB,gCAAgCnF,SAASqB,IAAI;AACtD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvjBA,IAAMmF,eAAe,CAAA;AAErB,IAAMC,mBAAmB;EACvBC,cAAaC,SAAAA,aAAAA,WAAWC,MAAM;AAC5B,QAAID,UAAUE,SAAS,GAAG;AACxB,UAAMC,aAAaH,UAAUA,UAAUE,SAAS;AAChD,UAAIC,eAAeF,MAAM;AACvBE,mBAAWC,MAAK;MAClB;IACF;AAEA,QAAMC,YAAYL,UAAUM,QAAQL,IAAI;AACxC,QAAII,cAAc,IAAI;AACpBL,gBAAUO,KAAKN,IAAI;IACrB,OAAO;AAELD,gBAAUQ,OAAOH,WAAW,CAAC;AAC7BL,gBAAUO,KAAKN,IAAI;IACrB;;EAGFQ,gBAAeT,SAAAA,eAAAA,WAAWC,MAAM;AAC9B,QAAMI,YAAYL,UAAUM,QAAQL,IAAI;AACxC,QAAII,cAAc,IAAI;AACpBL,gBAAUQ,OAAOH,WAAW,CAAC;IAC/B;AAEA,QAAIL,UAAUE,SAAS,GAAG;AACxBF,gBAAUA,UAAUE,SAAS,GAAGQ,QAAO;IACzC;EACF;AACF;AAEA,IAAMC,oBAAoB,SAApBA,mBAA8BC,MAAM;AACxC,SACEA,KAAKC,WACLD,KAAKC,QAAQC,YAAW,MAAO,WAC/B,OAAOF,KAAKG,WAAW;AAE3B;AAEA,IAAMC,gBAAgB,SAAhBA,eAA0BC,IAAG;AACjC,SAAOA,GAAEC,QAAQ,YAAYD,GAAEC,QAAQ,SAASD,GAAEE,YAAY;AAChE;AAEA,IAAMC,aAAa,SAAbA,YAAuBH,IAAG;AAC9B,SAAOA,GAAEC,QAAQ,SAASD,GAAEE,YAAY;AAC1C;AAEA,IAAME,QAAQ,SAARA,OAAkBC,IAAI;AAC1B,SAAOC,WAAWD,IAAI,CAAC;AACzB;AAIA,IAAME,YAAY,SAAZA,WAAsBC,KAAKH,IAAI;AACnC,MAAII,MAAM;AAEVD,MAAIE,MAAM,SAAUC,OAAOC,IAAG;AAC5B,QAAIP,GAAGM,KAAK,GAAG;AACbF,YAAMG;AACN,aAAO;IACT;AAEA,WAAO;EACT,CAAC;AAED,SAAOH;AACT;AASA,IAAMI,iBAAiB,SAAjBA,gBAA2BF,OAAkB;AAAA,WAAA,OAAA,UAAA,QAARG,SAAM,IAAA,MAAA,OAAA,IAAA,OAAA,IAAA,CAAA,GAAA,OAAA,GAAA,OAAA,MAAA,QAAA;AAANA,WAAM,OAAA,KAAA,UAAA;EAAA;AAC/C,SAAO,OAAOH,UAAU,aAAaA,MAASG,MAAAA,QAAAA,MAAM,IAAIH;AAC1D;AAEA,IAAMI,kBAAkB,SAAlBA,iBAA4BC,OAAO;AAQvC,SAAOA,MAAMC,OAAOC,cAAc,OAAOF,MAAMG,iBAAiB,aAC5DH,MAAMG,aAAY,EAAG,KACrBH,MAAMC;AACZ;AAEMG,IAAAA,kBAAkB,SAAlBA,iBAA4BC,UAAUC,aAAa;AAGvD,MAAMC,OAAMD,gBAAW,QAAXA,gBAAW,SAAA,SAAXA,YAAaE,aAAYA;AAErC,MAAMzC,aAAYuC,gBAAW,QAAXA,gBAAW,SAAA,SAAXA,YAAavC,cAAaH;AAE5C,MAAM6C,SAAMC,eAAA;IACVC,yBAAyB;IACzBC,mBAAmB;IACnBC,mBAAmB;EAAI,GACpBP,WAAW;AAGhB,MAAMQ,QAAQ;IAGZC,YAAY,CAAA;IAeZC,iBAAiB,CAAA;IAMjBC,gBAAgB,CAAA;IAEhBC,6BAA6B;IAC7BC,yBAAyB;IACzBC,QAAQ;IACRC,QAAQ;IAIRC,wBAAwBC;;AAG1B,MAAIvD;AAUJ,MAAMwD,YAAY,SAAZA,WAAaC,uBAAuBC,YAAYC,kBAAqB;AACzE,WAAOF,yBACLA,sBAAsBC,gBAAgBH,SACpCE,sBAAsBC,cACtBjB,OAAOkB,oBAAoBD;;AAUjC,MAAME,qBAAqB,SAArBA,oBAA+BC,SAAS;AAI5C,WAAOf,MAAME,gBAAgBzB,UAC3B,SAAA,MAAA;AAAA,UAAGuC,YAAS,KAATA,WAAWC,gBAAa,KAAbA;AAAa,aACzBD,UAAUE,SAASH,OAAO,KAK1BE,cAAcE,KAAK,SAACtD,MAAI;AAAA,eAAKA,SAASkD;OAAQ;KACjD;;AAgBH,MAAMK,mBAAmB,SAAnBA,kBAA6BR,YAAuB;AACxD,QAAIS,cAAc1B,OAAOiB;AAEzB,QAAI,OAAOS,gBAAgB,YAAY;AAAA,eAAA,QAAA,UAAA,QAHSrC,SAAM,IAAA,MAAA,QAAA,IAAA,QAAA,IAAA,CAAA,GAAA,QAAA,GAAA,QAAA,OAAA,SAAA;AAANA,eAAM,QAAA,KAAA,UAAA;MAAA;AAIpDqC,oBAAcA,YAAerC,MAAAA,QAAAA,MAAM;IACrC;AAEA,QAAIqC,gBAAgB,MAAM;AACxBA,oBAAcZ;IAChB;AAEA,QAAI,CAACY,aAAa;AAChB,UAAIA,gBAAgBZ,UAAaY,gBAAgB,OAAO;AACtD,eAAOA;MACT;AAGA,YAAM,IAAIC,MACHV,IAAAA,OAAAA,YACN,8DAAA,CAAA;IACH;AAEA,QAAI/C,OAAOwD;AAEX,QAAI,OAAOA,gBAAgB,UAAU;AACnCxD,aAAO4B,IAAI8B,cAAcF,WAAW;AACpC,UAAI,CAACxD,MAAM;AACT,cAAM,IAAIyD,MACHV,IAAAA,OAAAA,YACN,uCAAA,CAAA;MACH;IACF;AAEA,WAAO/C;;AAGT,MAAM2D,sBAAsB,SAAtBA,uBAAkC;AACtC,QAAI3D,OAAOuD,iBAAiB,cAAc;AAG1C,QAAIvD,SAAS,OAAO;AAClB,aAAO;IACT;AAEA,QAAIA,SAAS4C,QAAW;AAEtB,UAAIK,mBAAmBrB,IAAIgC,aAAa,KAAK,GAAG;AAC9C5D,eAAO4B,IAAIgC;MACb,OAAO;AACL,YAAMC,qBAAqB1B,MAAMG,eAAe;AAChD,YAAMwB,oBACJD,sBAAsBA,mBAAmBC;AAG3C9D,eAAO8D,qBAAqBP,iBAAiB,eAAe;MAC9D;IACF;AAEA,QAAI,CAACvD,MAAM;AACT,YAAM,IAAIyD,MACR,8DAA8D;IAElE;AAEA,WAAOzD;;AAGT,MAAM+D,sBAAsB,SAAtBA,uBAAkC;AACtC5B,UAAME,kBAAkBF,MAAMC,WAAW4B,IAAI,SAACb,WAAc;AAC1D,UAAMC,gBAAgBa,SAASd,WAAWrB,OAAOoC,eAAe;AAIhE,UAAMC,iBAAiBC,UAAUjB,WAAWrB,OAAOoC,eAAe;AAElE,aAAO;QACLf;QACAC;QACAe;QACAL,mBAAmBV,cAAc9D,SAAS,IAAI8D,cAAc,KAAK;QACjEiB,kBACEjB,cAAc9D,SAAS,IACnB8D,cAAcA,cAAc9D,SAAS,KACrC;QAUNgF,kBAAgB,SAAA,iBAACtE,MAAsB;AAAA,cAAhBuE,UAAO,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAAG;AAW/B,cAAMC,UAAUL,eAAevD,UAAU,SAAC6D,IAAC;AAAA,mBAAKA,OAAMzE;WAAK;AAC3D,cAAIwE,UAAU,GAAG;AACf,mBAAO5B;UACT;AAEA,cAAI2B,SAAS;AACX,mBAAOJ,eACJO,MAAMF,UAAU,CAAC,EACjBlB,KAAK,SAACmB,IAAC;AAAA,qBAAKE,WAAWF,IAAG3C,OAAOoC,eAAe;aAAE;UACvD;AAEA,iBAAOC,eACJO,MAAM,GAAGF,OAAO,EAChBI,QAAO,EACPtB,KAAK,SAACmB,IAAC;AAAA,mBAAKE,WAAWF,IAAG3C,OAAOoC,eAAe;WAAE;QACvD;;IAEJ,CAAC;AAED/B,UAAMG,iBAAiBH,MAAME,gBAAgBwC,OAC3C,SAACC,OAAK;AAAA,aAAKA,MAAM1B,cAAc9D,SAAS;KACzC;AAGD,QACE6C,MAAMG,eAAehD,UAAU,KAC/B,CAACiE,iBAAiB,eAAe,GACjC;AACA,YAAM,IAAIE,MACR,qGAAqG;IAEzG;;AAGF,MAAMsB,WAAW,SAAXA,UAAqB/E,MAAM;AAC/B,QAAIA,SAAS,OAAO;AAClB;IACF;AAEA,QAAIA,SAAS4B,IAAIgC,eAAe;AAC9B;IACF;AAEA,QAAI,CAAC5D,QAAQ,CAACA,KAAKgF,OAAO;AACxBD,MAAAA,UAASpB,oBAAmB,CAAE;AAC9B;IACF;AAEA3D,SAAKgF,MAAM;MAAEC,eAAe,CAAC,CAACnD,OAAOmD;IAAc,CAAC;AACpD9C,UAAMK,0BAA0BxC;AAEhC,QAAID,kBAAkBC,IAAI,GAAG;AAC3BA,WAAKG,OAAM;IACb;;AAGF,MAAM+E,qBAAqB,SAArBA,oBAA+BC,uBAAuB;AAC1D,QAAMnF,OAAOuD,iBAAiB,kBAAkB4B,qBAAqB;AACrE,WAAOnF,OAAOA,OAAOA,SAAS,QAAQ,QAAQmF;;AAKhD,MAAMC,mBAAmB,SAAnBA,kBAA6B/E,IAAG;AACpC,QAAMiB,SAASF,gBAAgBf,EAAC;AAEhC,QAAI4C,mBAAmB3B,MAAM,KAAK,GAAG;AAEnC;IACF;AAEA,QAAIJ,eAAeY,OAAOuD,yBAAyBhF,EAAC,GAAG;AAErDhB,WAAKiG,WAAW;QAYdC,aACEzD,OAAOE,2BACP,CAACwD,YAAYlE,QAAQQ,OAAOoC,eAAe;MAC/C,CAAC;AACD;IACF;AAKA,QAAIhD,eAAeY,OAAO2D,mBAAmBpF,EAAC,GAAG;AAE/C;IACF;AAGAA,IAAAA,GAAEqF,eAAc;;AAIlB,MAAMC,eAAe,SAAfA,cAAyBtF,IAAG;AAChC,QAAMiB,SAASF,gBAAgBf,EAAC;AAChC,QAAMuF,kBAAkB3C,mBAAmB3B,MAAM,KAAK;AAGtD,QAAIsE,mBAAmBtE,kBAAkBuE,UAAU;AACjD,UAAID,iBAAiB;AACnBzD,cAAMK,0BAA0BlB;MAClC;IACF,OAAO;AAELjB,MAAAA,GAAEyF,yBAAwB;AAC1Bf,eAAS5C,MAAMK,2BAA2BmB,oBAAmB,CAAE;IACjE;;AAOF,MAAMoC,WAAW,SAAXA,UAAqB1F,IAAG;AAC5B,QAAMiB,SAASF,gBAAgBf,EAAC;AAChC0D,wBAAmB;AAEnB,QAAIiC,kBAAkB;AAEtB,QAAI7D,MAAMG,eAAehD,SAAS,GAAG;AAInC,UAAM2G,iBAAiBhD,mBAAmB3B,MAAM;AAChD,UAAM4E,iBACJD,kBAAkB,IAAI9D,MAAME,gBAAgB4D,kBAAkBrD;AAEhE,UAAIqD,iBAAiB,GAAG;AAGtB,YAAI5F,GAAE8F,UAAU;AAEdH,4BACE7D,MAAMG,eAAeH,MAAMG,eAAehD,SAAS,GAChD+E;QACP,OAAO;AAEL2B,4BAAkB7D,MAAMG,eAAe,GAAGwB;QAC5C;MACF,WAAWzD,GAAE8F,UAAU;AAIrB,YAAIC,oBAAoBxF,UACtBuB,MAAMG,gBACN,SAAA,OAAA;AAAA,cAAGwB,oBAAiB,MAAjBA;AAAiB,iBAAOxC,WAAWwC;SACvC;AAED,YACEsC,oBAAoB,MACnBF,eAAe/C,cAAc7B,UAC3BkE,YAAYlE,QAAQQ,OAAOoC,eAAe,KACzC,CAACS,WAAWrD,QAAQQ,OAAOoC,eAAe,KAC1C,CAACgC,eAAe5B,iBAAiBhD,QAAQ,KAAK,IAClD;AAOA8E,8BAAoBH;QACtB;AAEA,YAAIG,qBAAqB,GAAG;AAI1B,cAAMC,wBACJD,sBAAsB,IAClBjE,MAAMG,eAAehD,SAAS,IAC9B8G,oBAAoB;AAE1B,cAAME,mBAAmBnE,MAAMG,eAAe+D;AAC9CL,4BAAkBM,iBAAiBjC;QACrC;MACF,OAAO;AAIL,YAAIkC,mBAAmB3F,UACrBuB,MAAMG,gBACN,SAAA,OAAA;AAAA,cAAG+B,mBAAgB,MAAhBA;AAAgB,iBAAO/C,WAAW+C;SACtC;AAED,YACEkC,mBAAmB,MAClBL,eAAe/C,cAAc7B,UAC3BkE,YAAYlE,QAAQQ,OAAOoC,eAAe,KACzC,CAACS,WAAWrD,QAAQQ,OAAOoC,eAAe,KAC1C,CAACgC,eAAe5B,iBAAiBhD,MAAM,IAC3C;AAOAiF,6BAAmBN;QACrB;AAEA,YAAIM,oBAAoB,GAAG;AAIzB,cAAMF,yBACJE,qBAAqBpE,MAAMG,eAAehD,SAAS,IAC/C,IACAiH,mBAAmB;AAEzB,cAAMD,oBAAmBnE,MAAMG,eAAe+D;AAC9CL,4BAAkBM,kBAAiBxC;QACrC;MACF;IACF,OAAO;AAELkC,wBAAkBzC,iBAAiB,eAAe;IACpD;AAEA,QAAIyC,iBAAiB;AACnB3F,MAAAA,GAAEqF,eAAc;AAChBX,eAASiB,eAAe;IAC1B;;AAIF,MAAMQ,WAAW,SAAXA,UAAqBnG,IAAG;AAC5B,QACED,cAAcC,EAAC,KACfa,eAAeY,OAAOG,mBAAmB5B,EAAC,MAAM,OAChD;AACAA,MAAAA,GAAEqF,eAAc;AAChBrG,WAAKiG,WAAU;AACf;IACF;AAEA,QAAI9E,WAAWH,EAAC,GAAG;AACjB0F,eAAS1F,EAAC;AACV;IACF;;AAGF,MAAMoG,aAAa,SAAbA,YAAuBpG,IAAG;AAC9B,QAAMiB,SAASF,gBAAgBf,EAAC;AAEhC,QAAI4C,mBAAmB3B,MAAM,KAAK,GAAG;AACnC;IACF;AAEA,QAAIJ,eAAeY,OAAOuD,yBAAyBhF,EAAC,GAAG;AACrD;IACF;AAEA,QAAIa,eAAeY,OAAO2D,mBAAmBpF,EAAC,GAAG;AAC/C;IACF;AAEAA,IAAAA,GAAEqF,eAAc;AAChBrF,IAAAA,GAAEyF,yBAAwB;;AAO5B,MAAMY,eAAe,SAAfA,gBAA2B;AAC/B,QAAI,CAACvE,MAAMM,QAAQ;AACjB;IACF;AAGAvD,qBAAiBC,aAAaC,WAAWC,IAAI;AAI7C8C,UAAMQ,yBAAyBb,OAAOI,oBAClCzB,MAAM,WAAY;AAChBsE,eAASpB,oBAAmB,CAAE;IAChC,CAAC,IACDoB,SAASpB,oBAAmB,CAAE;AAElC/B,QAAI+E,iBAAiB,WAAWhB,cAAc,IAAI;AAClD/D,QAAI+E,iBAAiB,aAAavB,kBAAkB;MAClDwB,SAAS;MACTC,SAAS;IACX,CAAC;AACDjF,QAAI+E,iBAAiB,cAAcvB,kBAAkB;MACnDwB,SAAS;MACTC,SAAS;IACX,CAAC;AACDjF,QAAI+E,iBAAiB,SAASF,YAAY;MACxCG,SAAS;MACTC,SAAS;IACX,CAAC;AACDjF,QAAI+E,iBAAiB,WAAWH,UAAU;MACxCI,SAAS;MACTC,SAAS;IACX,CAAC;AAED,WAAOxH;;AAGT,MAAMyH,kBAAkB,SAAlBA,mBAA8B;AAClC,QAAI,CAAC3E,MAAMM,QAAQ;AACjB;IACF;AAEAb,QAAImF,oBAAoB,WAAWpB,cAAc,IAAI;AACrD/D,QAAImF,oBAAoB,aAAa3B,kBAAkB,IAAI;AAC3DxD,QAAImF,oBAAoB,cAAc3B,kBAAkB,IAAI;AAC5DxD,QAAImF,oBAAoB,SAASN,YAAY,IAAI;AACjD7E,QAAImF,oBAAoB,WAAWP,UAAU,IAAI;AAEjD,WAAOnH;;AAOTA,SAAO;IACL,IAAIoD,SAAS;AACX,aAAON,MAAMM;;IAGf,IAAIC,SAAS;AACX,aAAOP,MAAMO;;IAGfsE,UAAQ,SAAA,SAACC,iBAAiB;AACxB,UAAI9E,MAAMM,QAAQ;AAChB,eAAO;MACT;AAEA,UAAMyE,aAAarE,UAAUoE,iBAAiB,YAAY;AAC1D,UAAME,iBAAiBtE,UAAUoE,iBAAiB,gBAAgB;AAClE,UAAMG,oBAAoBvE,UAAUoE,iBAAiB,mBAAmB;AAExE,UAAI,CAACG,mBAAmB;AACtBrD,4BAAmB;MACrB;AAEA5B,YAAMM,SAAS;AACfN,YAAMO,SAAS;AACfP,YAAMI,8BAA8BX,IAAIgC;AAExC,UAAIsD,YAAY;AACdA,mBAAU;MACZ;AAEA,UAAMG,mBAAmB,SAAnBA,oBAAyB;AAC7B,YAAID,mBAAmB;AACrBrD,8BAAmB;QACrB;AACA2C,qBAAY;AACZ,YAAIS,gBAAgB;AAClBA,yBAAc;QAChB;;AAGF,UAAIC,mBAAmB;AACrBA,0BAAkBjF,MAAMC,WAAWkF,OAAM,CAAE,EAAEC,KAC3CF,kBACAA,gBAAgB;AAElB,eAAO;MACT;AAEAA,uBAAgB;AAChB,aAAO;;IAGT/B,YAAU,SAAA,WAACkC,mBAAmB;AAC5B,UAAI,CAACrF,MAAMM,QAAQ;AACjB,eAAO;MACT;AAEA,UAAMgF,UAAO1F,eAAA;QACX2F,cAAc5F,OAAO4F;QACrBC,kBAAkB7F,OAAO6F;QACzBC,qBAAqB9F,OAAO8F;MAAmB,GAC5CJ,iBAAiB;AAGtBK,mBAAa1F,MAAMQ,sBAAsB;AACzCR,YAAMQ,yBAAyBC;AAE/BkE,sBAAe;AACf3E,YAAMM,SAAS;AACfN,YAAMO,SAAS;AAEfxD,uBAAiBW,eAAeT,WAAWC,IAAI;AAE/C,UAAMqI,eAAe7E,UAAU4E,SAAS,cAAc;AACtD,UAAME,mBAAmB9E,UAAU4E,SAAS,kBAAkB;AAC9D,UAAMG,sBAAsB/E,UAAU4E,SAAS,qBAAqB;AACpE,UAAMlC,cAAc1C,UAClB4E,SACA,eACA,yBAAyB;AAG3B,UAAIC,cAAc;AAChBA,qBAAY;MACd;AAEA,UAAMI,qBAAqB,SAArBA,sBAA2B;AAC/BrH,cAAM,WAAM;AACV,cAAI8E,aAAa;AACfR,qBAASG,mBAAmB/C,MAAMI,2BAA2B,CAAC;UAChE;AACA,cAAIoF,kBAAkB;AACpBA,6BAAgB;UAClB;QACF,CAAC;;AAGH,UAAIpC,eAAeqC,qBAAqB;AACtCA,4BACE1C,mBAAmB/C,MAAMI,2BAA2B,CAAC,EACrDgF,KAAKO,oBAAoBA,kBAAkB;AAC7C,eAAO;MACT;AAEAA,yBAAkB;AAClB,aAAO;;IAGTtI,OAAQ,SAAA,QAAA;AACN,UAAI2C,MAAMO,UAAU,CAACP,MAAMM,QAAQ;AACjC,eAAO;MACT;AAEAN,YAAMO,SAAS;AACfoE,sBAAe;AAEf,aAAO;;IAGThH,SAAU,SAAA,UAAA;AACR,UAAI,CAACqC,MAAMO,UAAU,CAACP,MAAMM,QAAQ;AAClC,eAAO;MACT;AAEAN,YAAMO,SAAS;AACfqB,0BAAmB;AACnB2C,mBAAY;AAEZ,aAAO;;IAGTqB,yBAAuB,SAAA,wBAACC,mBAAmB;AACzC,UAAMC,kBAAkB,CAAA,EAAGX,OAAOU,iBAAiB,EAAEnD,OAAOqD,OAAO;AAEnE/F,YAAMC,aAAa6F,gBAAgBjE,IAAI,SAACd,SAAO;AAAA,eAC7C,OAAOA,YAAY,WAAWtB,IAAI8B,cAAcR,OAAO,IAAIA;OAC5D;AAED,UAAIf,MAAMM,QAAQ;AAChBsB,4BAAmB;MACrB;AAEA,aAAO;IACT;;AAIF1E,OAAK0I,wBAAwBrG,QAAQ;AAErC,SAAOrC;AACT;;;AChxBO,IAAM,WAAW,CAAC,QAAa,QAAQ,QAAQ,QAAQ;AAEvD,IAAM,YAAY,CAAC,YACxB,CAAC,EAAE,QAAQ,eAAe,QAAQ,gBAAgB,QAAQ,eAAe,EAAE,SAAS;AAE/E,IAAM,WAAW,CAAI,SAAY,SAAiB,CAAC,QAAQ,QAAQ,MACxE,YAAY,OAAO,KAAK,OAAO,KAAK,OAAO;;;ACN7C,IAAqB,cAArB,MAAiC;AAAA,EAAjC;AACE,SAAQ,cAA0B,CAAC;AAAA;AAAA,EAEnC,IAAI,UAAsB;AACxB,SAAK,YAAY,KAAK,QAAQ;AAC9B,WAAO,MAAM;AACX,UAAI,MAAM,KAAK,YAAY,QAAQ,QAAQ;AAC3C,UAAI,OAAO,GAAG;AACZ,YAAI,CAAC,OAAO,IAAI,KAAK,YAAY,OAAO,KAAK,CAAC;AAC9C,gBAAQ;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAAA,EAEA,UAAU,UAAsB;AAC9B,UAAM,MAAM,sBAAsB,MAAM,sBAAsB,QAAQ,CAAC;AACvE,WAAO,KAAK,IAAI,MAAM,qBAAqB,GAAG,CAAC;AAAA,EACjD;AAAA,EAEA,iBACE,SACA,OACA,UACA,SACA;AACA,YAAQ,iBAAiB,OAAO,UAAU,OAAO;AACjD,WAAO,KAAK,IAAI,MAAM,QAAQ,oBAAoB,OAAO,QAAQ,CAAC;AAAA,EACpE;AAAA,EAEA,WAAW,SAAqB,SAAkB;AAChD,UAAM,KAAK,OAAO,WAAW,SAAS,OAAO;AAC7C,WAAO,KAAK,IAAI,MAAM,aAAa,EAAE,CAAC;AAAA,EACxC;AAAA,EAEA,UAAU;AACR,SAAK,YAAY,OAAO,CAAC,EAAE,QAAQ,CAAC8I,OAAMA,GAAE,CAAC;AAAA,EAC/C;AACF;;;AC1BA,IAAqB,QAArB,MAA2B;AAAA,EASzB,YAAY,SAAsB,SAAwB;AAH1D,SAAQ,YAAY,IAAI,YAAY;AACpC,SAAQ,cAAc,IAAI,YAAY;AAlBxC;AAqBI,SAAK,UAAU;AAEf,SAAK,iBAAgB,wCAAS,kBAAT,YAA0B;AAC/C,SAAK,gBAAe,wCAAS,iBAAT,YAAyB;AAC7C,SAAK,sBAAqB,wCAAS,uBAAT,YAA+B;AAAA,EAC3D;AAAA,EAEA,kBAAkB,WAAuB;AACvC,QAAI,KAAK,oBAAoB;AAC3B,WAAK,UAAU,iBAAiB,UAAU,SAAS,CAAC,UAAU;AAC5D,YAAI,UAAU,KAAK,OAAO,KAAK,CAAC,KAAK,QAAQ,SAAS,MAAM,MAAiB,GAAG;AAC9E,oBAAU;AACV,gBAAM,eAAe;AAAA,QACvB;AAAA,MACF,CAAC;AAAA,IACH;AACA,QAAI,KAAK,cAAc;AACrB,WAAK,UAAU,iBAAiB,UAAU,WAAW,CAAC,UAAU;AAC9D,cAAM,EAAE,IAAI,IAAI;AAChB,YAAI,UAAU,KAAK,OAAO,KAAK,QAAQ,UAAU;AAC/C,oBAAU;AACV,gBAAM,eAAe;AAAA,QACvB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,uBAAuB;AACrB,SAAK,UAAU,QAAQ;AAAA,EACzB;AAAA,EAEA,WAAW;AACT,UAAM,YAAY,gBAAgB,KAAK,SAAS;AAAA,MAC9C,mBAAmB;AAAA,MACnB,mBAAmB;AAAA,IACrB,CAAC;AACD,SAAK,YAAY,IAAI,MAAM,UAAU,WAAW,CAAC;AACjD,SAAK,YAAY,UAAU,MAAM,UAAU,SAAS,CAAC;AACrD,qBAAiB,KAAK,gBAAgB,QAAQ,MAAS;AAAA,EACzD;AAAA,EAEA,aAAa;AACX,SAAK,YAAY,QAAQ;AACzB,qBAAiB,KAAK,gBAAgB,OAAO,MAAS;AAAA,EACxD;AACF;;;AChEA,IAAqB,gBAArB,cAAuF,YAAY;AAAA,EAIjG,yBACE,WACA,UACA,UACA;AAIA,QAAI,aAAa,QAAQ,aAAa;AAAM;AAC5C,QAAI,aAAa;AAAU;AAC3B,SAAK,gBAAgB,WAAW,UAAU,QAAQ;AAAA,EACpD;AAAA,EAEA,gBACE,YACA,WACA,WACA;AAAA,EAAE;AAAA,EAEJ,UAAU,SAAsB,SAAoC;AAClE,WAAO,WAAW,OAAO,SAAS,WAAW,IAAI;AAAA,EACnD;AAAA,EAEA,iBAAiB,SAAsB,MAAc,OAAe;AAClE,SAAK,UAAU,SAAS,KAAK,UAAU,CAAC,CAAC,YAAY,EAAE,MAAM,CAAC,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,EAC3F;AAAA,EAEA,oBAAoB,SAAsB,MAAc;AACtD,SAAK,UAAU,SAAS,KAAK,UAAU,CAAC,CAAC,eAAe,EAAE,MAAM,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,EACrF;AAAA,EAEA,aAAa,OAAgB;AAC3B,SAAK,iBAAiB,MAAM,cAAc,KAAK;AAAA,EACjD;AACF;AApCE;AAAA,EADC,KAAK,YAAY;AAAA,GADC,cAEnB;;;ACUF,IAAM,uBAAuB,CAAC,YAC5B,OAAO;AAAA,EACL,CAAC,SAAS,OAAO,EACd,IAAI,CAACC,OAAM,CAACA,IAAG,GAAGA,UAAS,GAAGA,MAAK,CAAC,EACpC,KAAK,EACL,IAAI,CAAC,QAAK;AAnBjB;AAmBoB,YAAC,MAAK,yBAAQ,QAAQ,SAAhB,mBAAsB,MAAM,SAA5B,mBAAkC,OAAO,aAAzC,YAAqD,CAAC,CAAC;AAAA,GAAU;AACzF;AAEF,IAAM,oBAAoB,CAAC,SAAsB,WAA+C;AAC9F,MAAI,EAAE,oBAAoB,gBAAgB,IAAI,iBAAiB,OAAO;AAEtE,MAAI,gBAAgB,CAAC,oBAAoB,eAAe,EACrD,IAAI,CAAC,UAAU;AACd,QAAI,CAAC,gBAAgB,CAAC,IAAI,MACvB,MAAM,GAAG,EACT,OAAO,OAAO,EACd,IAAI,CAACA,OAAOA,GAAE,SAAS,IAAI,IAAI,WAAWA,EAAC,IAAI,WAAWA,EAAC,IAAI,GAAK,EACpE,KAAK,CAACC,IAAGC,OAAMA,KAAID,EAAC;AAEvB,WAAO;AAAA,EACT,CAAC,EACA,OAAO,CAACA,IAAGE,OAAMF,KAAIE,IAAG,CAAC;AAE5B,QAAMC,KAAI,IAAI,YAAY;AAE1B,MAAI,kBAAkB,GAAG;AACvB,WAAO,OAAO;AAAA,EAChB,OAAO;AACL,UAAM,YAA4B,CAAC;AAEnC,cAAU;AAAA,MACRA,GAAE,iBAAiB,SAAS,iBAAiB,CAAC,UAAU;AACtD,YAAI,MAAM,WAAW,MAAM;AAAe;AAE1C,kBAAU,OAAO,CAAC,EAAE,QAAQ,CAACA,OAAMA,GAAE,CAAC;AAEtC,kBAAU;AAAA,UACRA,GAAE,iBAAiB,SAAS,iBAAiB,CAACC,WAAU;AACtD,gBAAIA,OAAM,WAAWA,OAAM;AAAe;AAC1C,mBAAO,OAAO;AACd,sBAAU,OAAO,CAAC,EAAE,QAAQ,CAACD,OAAMA,GAAE,CAAC;AAAA,UACxC,CAAC;AAAA,UACDA,GAAE,iBAAiB,SAAS,oBAAoB,CAACC,WAAU;AACzD,gBAAIA,OAAM,WAAWA,OAAM;AAAe;AAC1C,mBAAO,UAAU;AACjB,sBAAU,OAAO,CAAC,EAAE,QAAQ,CAACD,OAAMA,GAAE,CAAC;AAAA,UACxC,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,EAAAA,GAAE,IAAI,MAAM,OAAO,UAAU,CAAC;AAE9B,SAAOA,GAAE;AACX;AAEO,IAAM,eAAe,CAC1B,SACA,OACA,SACA,cAIG;AA/EL;AAgFE,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,UAAQ,OAAO;AAAA,IACb,KAAK;AACH,aAAO,QAAQ;AACf,aAAO,QAAQ;AACf,WAAK,QAAQ;AACb;AAAA,IACF,KAAK;AACH,aAAO,QAAQ;AACf,aAAO,QAAQ;AACf,WAAK,QAAQ;AACb;AAAA,EACJ;AAEA,kBAAU,YAAV,mCAAoB;AAEpB,UAAQ,UAAU,IAAI,GAAG,MAAM,GAAG,IAAI;AAEtC,QAAMA,KAAI,IAAI,YAAY;AAC1B,EAAAA,GAAE,UAAU,MAAM;AAChB,YAAQ,UAAU,OAAO,GAAG,IAAI;AAChC,YAAQ,UAAU,IAAI,GAAG,EAAE;AAE3B,sBAAkB,SAAS,CAAC,WAAW;AAzG3C,UAAAE;AA0GM,UAAI,WAAW,SAAS;AACtB,gBAAQ,UAAU,OAAO,GAAG,IAAI;AAAA,MAClC;AACA,OAAAA,MAAA,UAAU,WAAV,gBAAAA,IAAA,gBAAmB,OAAO;AAAA,IAC5B,CAAC;AAAA,EACH,CAAC;AAED,SAAOF,GAAE;AACX;AAEO,IAAM,oBAAoB,CAAC,SAAsB,UACtD,IAAI,QAAsC,CAAC,YAAY;AACrD,MAAI,CAAC,QAAQ,aAAa,iBAAiB,GAAG;AAC5C,YAAQ,MAAS;AACjB;AAAA,EACF;AAEA,QAAM,UAAU,qBAAqB,OAAO;AAC5C,eAAa,SAAS,OAAO,SAAS;AAAA,IACpC,QAAQ,CAAC,QAAQ,WAAW,QAAQ,MAAM;AAAA,EAC5C,CAAC;AACH,CAAC;;;ACxHH,IAAM,gBAAN,cAA4B,cAAc;AAAA,EAUxC,WAAW,qBAAqB;AAC9B,WAAO,CAAC,YAAY;AAAA,EACtB;AAAA,EAEA,oBAAoB;AAClB,QAAI,CAAC,KAAK,UAAU,CAAC,KAAK,YAAY,CAAC,KAAK;AAC1C,YAAM,IAAI,MAAM,0DAA0D;AAE5E,SAAK,QAAQ,IAAI,MAAM,KAAK,OAAO;AAAA,MACjC,eAAe,SAAS,KAAK,QAAQ,aAAa;AAAA,MAClD,cAAc,SAAS,KAAK,QAAQ,UAAU;AAAA,MAC9C,oBAAoB,SAAS,KAAK,QAAQ,gBAAgB;AAAA,IAC5D,CAAC;AAAA,EACH;AAAA,EAEA,gBAAgB,WAAmB,WAAoB,WAAoB;AACzE,QAAI,cAAc;AAAc,WAAK,kBAAkB;AAAA,EACzD;AAAA,EAEM,oBAAoB;AAAA;AACxB,YAAM,QAAQ,CAAC,KAAK,UAAU,KAAK,KAAK;AAExC,UAAI,KAAK,UAAU,QAAQ;AACzB,aAAK,UAAU,MAAM,KAAK,QAAQ,QAAQ;AAE1C,aAAK,oBAAoB,KAAK,QAAQ,QAAQ;AAC9C,aAAK,MAAM,kBAAkB,MAAM;AACjC,eAAK,aAAa,QAAQ;AAAA,QAC5B,CAAC;AACD,aAAK,MAAM,SAAS;AAEpB,cAAM,QAAQ,IAAI,MAAM,IAAI,CAAC,SAAS,kBAAkB,MAAM,OAAO,CAAC,CAAC;AAAA,MACzE,OAAO;AACL,aAAK,UAAU,MAAM,KAAK,QAAQ,SAAS;AAE3C,aAAK,MAAM,qBAAqB;AAChC,aAAK,MAAM,WAAW;AACtB,cAAM,QAAQ,IAAI,MAAM,IAAI,CAAC,SAAS,kBAAkB,MAAM,OAAO,CAAC,CAAC;AACvE,aAAK,iBAAiB,KAAK,QAAQ,UAAU,MAAM;AAAA,MACrD;AAAA,IACF;AAAA;AACF;AAjDE;AAAA,EADC,MAAM,WAAW;AAAA,GADd,cAEJ;AAEA;AAAA,EADC,MAAM,UAAU;AAAA,GAHb,cAIJ;AAEA;AAAA,EADC,MAAM,OAAO;AAAA,GALV,cAMJ;AA+CF,IAAM,SAA+B,CAAC,WAAW;AAAA,EAC/C,MAAM,MAAM;AACV,mBAAe,OAAO,aAAa,aAAa;AAAA,EAClD;AACF;AAEA,IAAO,iBAAQ;;;AClEf,SAAS,EAAEG,IAAE;AAAC,SAAOA,GAAE,MAAM,GAAG,EAAE;AAAE;AAAC,SAAS,EAAEA,IAAE;AAAC,SAAOA,GAAE,MAAM,GAAG,EAAE;AAAE;AAAC,SAAS,EAAEC,IAAE;AAAC,SAAM,CAAC,OAAM,QAAQ,EAAE,SAAS,EAAEA,EAAC,CAAC,IAAE,MAAI;AAAG;AAAC,SAAS,EAAED,IAAE;AAAC,SAAM,QAAMA,KAAE,WAAS;AAAO;AAAC,SAAS,EAAEE,IAAEC,IAAEC,IAAE;AAAC,MAAG,EAAC,WAAUC,IAAE,UAASC,GAAC,IAAEJ;AAAE,QAAMK,KAAEF,GAAE,IAAEA,GAAE,QAAM,IAAEC,GAAE,QAAM,GAAEE,KAAEH,GAAE,IAAEA,GAAE,SAAO,IAAEC,GAAE,SAAO,GAAEG,KAAE,EAAEN,EAAC,GAAEO,KAAE,EAAED,EAAC,GAAEE,KAAEN,GAAEK,MAAG,IAAEJ,GAAEI,MAAG,GAAEE,KAAE,QAAMH;AAAE,MAAII;AAAE,UAAO,EAAEV,EAAC,GAAE;AAAA,IAAC,KAAI;AAAM,MAAAU,KAAE,EAAC,GAAEN,IAAE,GAAEF,GAAE,IAAEC,GAAE,OAAM;AAAE;AAAA,IAAM,KAAI;AAAS,MAAAO,KAAE,EAAC,GAAEN,IAAE,GAAEF,GAAE,IAAEA,GAAE,OAAM;AAAE;AAAA,IAAM,KAAI;AAAQ,MAAAQ,KAAE,EAAC,GAAER,GAAE,IAAEA,GAAE,OAAM,GAAEG,GAAC;AAAE;AAAA,IAAM,KAAI;AAAO,MAAAK,KAAE,EAAC,GAAER,GAAE,IAAEC,GAAE,OAAM,GAAEE,GAAC;AAAE;AAAA,IAAM;AAAQ,MAAAK,KAAE,EAAC,GAAER,GAAE,GAAE,GAAEA,GAAE,EAAC;AAAA,EAAC;AAAC,UAAO,EAAEF,EAAC,GAAE;AAAA,IAAC,KAAI;AAAQ,MAAAU,GAAEJ,OAAIE,MAAGP,MAAGQ,KAAE,KAAG;AAAG;AAAA,IAAM,KAAI;AAAM,MAAAC,GAAEJ,OAAIE,MAAGP,MAAGQ,KAAE,KAAG;AAAA,EAAE;AAAC,SAAOC;AAAC;AAAC,IAAM,IAAE,OAAMb,IAAEC,IAAEa,OAAI;AAAC,QAAK,EAAC,WAAUC,KAAE,UAAS,UAASZ,KAAE,YAAW,YAAWC,KAAE,CAAC,GAAE,UAASC,GAAC,IAAES,IAAER,KAAE,OAAM,QAAMD,GAAE,QAAM,SAAOA,GAAE,MAAMJ,EAAC;AAAG,MAAIM,KAAE,MAAMF,GAAE,gBAAgB,EAAC,WAAUL,IAAE,UAASC,IAAE,UAASE,GAAC,CAAC,GAAE,EAAC,GAAEK,IAAE,GAAEC,GAAC,IAAE,EAAEF,IAAEQ,IAAET,EAAC,GAAEI,KAAEK,IAAEJ,KAAE,CAAC,GAAEC,KAAE;AAAE,WAAQE,KAAE,GAAEA,KAAEV,GAAE,QAAOU,MAAI;AAAC,UAAK,EAAC,MAAKD,IAAE,IAAGG,GAAC,IAAEZ,GAAEU,KAAG,EAAC,GAAEG,IAAE,GAAEC,IAAE,MAAKC,IAAE,OAAMC,GAAC,IAAE,MAAMJ,GAAE,EAAC,GAAER,IAAE,GAAEC,IAAE,kBAAiBM,IAAE,WAAUL,IAAE,UAASP,IAAE,gBAAeQ,IAAE,OAAMJ,IAAE,UAASF,IAAE,UAAS,EAAC,WAAUL,IAAE,UAASC,GAAC,EAAC,CAAC;AAAE,IAAAO,KAAE,QAAMS,KAAEA,KAAET,IAAEC,KAAE,QAAMS,KAAEA,KAAET,IAAEE,KAAE,EAAC,GAAGA,IAAE,CAACE,KAAG,EAAC,GAAGF,GAAEE,KAAG,GAAGM,GAAC,EAAC,GAAEC,MAAGR,MAAG,OAAKA,MAAI,YAAU,OAAOQ,OAAIA,GAAE,cAAYV,KAAEU,GAAE,YAAWA,GAAE,UAAQb,KAAE,SAAKa,GAAE,QAAM,MAAMf,GAAE,gBAAgB,EAAC,WAAUL,IAAE,UAASC,IAAE,UAASE,GAAC,CAAC,IAAEiB,GAAE,QAAQ,EAAC,GAAEZ,IAAE,GAAEC,GAAC,IAAE,EAAEF,IAAEG,IAAEJ,EAAC,IAAIQ,KAAE;AAAA,EAAG;AAAC,SAAM,EAAC,GAAEN,IAAE,GAAEC,IAAE,WAAUC,IAAE,UAASP,IAAE,gBAAeQ,GAAC;AAAC;AAAE,SAAS,EAAEX,IAAE;AAAC,SAAM,YAAU,OAAOA,KAAE,SAASA,IAAE;AAAC,WAAM,EAAC,KAAI,GAAE,OAAM,GAAE,QAAO,GAAE,MAAK,GAAE,GAAGA,GAAC;AAAA,EAAC,EAAEA,EAAC,IAAE,EAAC,KAAIA,IAAE,OAAMA,IAAE,QAAOA,IAAE,MAAKA,GAAC;AAAC;AAAC,SAAS,EAAEA,IAAE;AAAC,SAAM,EAAC,GAAGA,IAAE,KAAIA,GAAE,GAAE,MAAKA,GAAE,GAAE,OAAMA,GAAE,IAAEA,GAAE,OAAM,QAAOA,GAAE,IAAEA,GAAE,OAAM;AAAC;AAAC,eAAe,EAAEA,IAAEC,IAAE;AAAC,MAAIa;AAAE,aAASb,OAAIA,KAAE,CAAC;AAAG,QAAK,EAAC,GAAEc,IAAE,GAAEb,IAAE,UAASC,IAAE,OAAMG,IAAE,UAASC,IAAE,UAASC,GAAC,IAAER,IAAE,EAAC,UAASS,KAAE,qBAAoB,cAAaC,KAAE,YAAW,gBAAeC,KAAE,YAAW,aAAYC,KAAE,OAAG,SAAQC,KAAE,EAAC,IAAEZ,IAAEe,KAAE,EAAEH,EAAC,GAAEI,KAAEV,GAAEK,KAAE,eAAaD,KAAE,cAAY,aAAWA,KAAGO,KAAE,EAAE,MAAMf,GAAE,gBAAgB,EAAC,SAAQ,SAAOW,KAAE,OAAM,QAAMX,GAAE,YAAU,SAAOA,GAAE,UAAUc,EAAC,OAAKH,KAAEG,KAAEA,GAAE,kBAAgB,OAAM,QAAMd,GAAE,qBAAmB,SAAOA,GAAE,mBAAmBI,GAAE,QAAQ,IAAG,UAASE,IAAE,cAAaC,IAAE,UAASF,GAAC,CAAC,CAAC,GAAEW,KAAE,EAAEhB,GAAE,wDAAsD,MAAMA,GAAE,sDAAsD,EAAC,MAAK,eAAaQ,KAAE,EAAC,GAAGL,GAAE,UAAS,GAAES,IAAE,GAAEb,GAAC,IAAEI,GAAE,WAAU,cAAa,OAAM,QAAMH,GAAE,kBAAgB,SAAOA,GAAE,gBAAgBI,GAAE,QAAQ,IAAG,UAASC,GAAC,CAAC,IAAEF,GAAEK,GAAE;AAAE,SAAM,EAAC,KAAIO,GAAE,MAAIC,GAAE,MAAIH,GAAE,KAAI,QAAOG,GAAE,SAAOD,GAAE,SAAOF,GAAE,QAAO,MAAKE,GAAE,OAAKC,GAAE,OAAKH,GAAE,MAAK,OAAMG,GAAE,QAAMD,GAAE,QAAMF,GAAE,MAAK;AAAC;AAAC,IAAM,IAAE,KAAK;AAAb,IAAiB,IAAE,KAAK;AAAI,SAAS,EAAEhB,IAAEC,IAAEa,IAAE;AAAC,SAAO,EAAEd,IAAE,EAAEC,IAAEa,EAAC,CAAC;AAAC;AAAC,IAAM,IAAE,CAAAd,QAAI,EAAC,MAAK,SAAQ,SAAQA,IAAE,MAAM,GAAGE,IAAE;AAAC,QAAK,EAAC,SAAQC,IAAE,SAAQE,KAAE,EAAC,IAAE,QAAML,KAAEA,KAAE,CAAC,GAAE,EAAC,GAAEM,IAAE,GAAEC,IAAE,WAAUC,IAAE,OAAME,IAAE,UAASC,GAAC,IAAET;AAAE,MAAG,QAAMC;AAAE,WAAM,CAAC;AAAE,QAAMS,KAAE,EAAEP,EAAC,GAAEQ,KAAE,EAAC,GAAEP,IAAE,GAAEC,GAAC,GAAES,KAAE,EAAER,EAAC,GAAES,KAAE,EAAET,EAAC,GAAEU,KAAE,EAAEF,EAAC,GAAEG,KAAE,MAAMR,GAAE,cAAcR,EAAC,GAAEiB,KAAE,QAAMJ,KAAE,QAAM,QAAOK,KAAE,QAAML,KAAE,WAAS,SAAQM,KAAEZ,GAAE,UAAUQ,MAAGR,GAAE,UAAUM,MAAGH,GAAEG,MAAGN,GAAE,SAASQ,KAAGK,KAAEV,GAAEG,MAAGN,GAAE,UAAUM,KAAGQ,KAAE,OAAM,QAAMb,GAAE,kBAAgB,SAAOA,GAAE,gBAAgBR,EAAC;AAAG,MAAIsB,KAAED,KAAE,QAAMR,KAAEQ,GAAE,gBAAc,IAAEA,GAAE,eAAa,IAAE;AAAE,QAAIC,OAAIA,KAAEf,GAAE,SAASQ;AAAI,QAAMQ,KAAEJ,KAAE,IAAEC,KAAE,GAAEI,KAAEf,GAAEQ,KAAGQ,KAAEH,KAAEN,GAAED,MAAGN,GAAES,KAAGQ,KAAEJ,KAAE,IAAEN,GAAED,MAAG,IAAEQ,IAAEI,KAAE,EAAEH,IAAEE,IAAED,EAAC,GAAEG,MAAG,YAAUd,KAAEL,GAAEQ,MAAGR,GAAES,OAAI,KAAGQ,OAAIC,MAAGpB,GAAE,UAAUQ,OAAIR,GAAE,SAASQ;AAAG,SAAM,EAAC,CAACF,KAAGH,GAAEG,OAAIe,KAAEF,KAAEF,KAAEA,KAAEE,KAAED,KAAEC,KAAE,IAAG,MAAK,EAAC,CAACb,KAAGc,IAAE,cAAaD,KAAEC,GAAC,EAAC;AAAC,EAAC;AAA1qB,IAA6qB,IAAE,EAAC,MAAK,SAAQ,OAAM,QAAO,QAAO,OAAM,KAAI,SAAQ;AAAE,SAAS,EAAE9B,IAAE;AAAC,SAAOA,GAAE,QAAQ,0BAA0B,CAAAA,OAAG,EAAEA,GAAG;AAAC;AAAC,SAAS,EAAEA,IAAEE,IAAEC,IAAE;AAAC,aAASA,OAAIA,KAAE;AAAI,QAAMC,KAAE,EAAEJ,EAAC,GAAEK,KAAE,EAAEL,EAAC,GAAEM,KAAE,EAAED,EAAC;AAAE,MAAIE,KAAE,QAAMF,KAAED,QAAKD,KAAE,QAAM,WAAS,UAAQ,SAAO,YAAUC,KAAE,WAAS;AAAM,SAAOF,GAAE,UAAUI,MAAGJ,GAAE,SAASI,QAAKC,KAAE,EAAEA,EAAC,IAAG,EAAC,MAAKA,IAAE,OAAM,EAAEA,EAAC,EAAC;AAAC;AAAC,IAAM,IAAE,EAAC,OAAM,OAAM,KAAI,QAAO;AAAE,SAAS,EAAEP,IAAE;AAAC,SAAOA,GAAE,QAAQ,cAAc,CAAAA,OAAG,EAAEA,GAAG;AAAC;AAAC,IAAM,IAAE,CAAC,OAAM,SAAQ,UAAS,MAAM;AAAtC,IAAwC,IAAE,EAAE,OAAQ,CAACA,IAAEC,OAAID,GAAE,OAAOC,IAAEA,KAAE,UAASA,KAAE,MAAM,GAAG,CAAC,CAAC;AAAijC,IAAM,IAAE,SAAS+B,IAAE;AAAC,SAAO,WAASA,OAAIA,KAAE,CAAC,IAAG,EAAC,MAAK,QAAO,SAAQA,IAAE,MAAM,GAAGC,IAAE;AAAC,QAAIC;AAAE,UAAK,EAAC,WAAUC,IAAE,gBAAeC,IAAE,OAAMC,IAAE,kBAAiBC,IAAE,UAASC,IAAE,UAASC,GAAC,IAAEP,IAAE,EAAC,UAASQ,KAAE,MAAG,WAAUC,KAAE,MAAG,oBAAmBC,IAAE,kBAAiBC,KAAE,WAAU,eAAcC,KAAE,SAAMC,GAAC,IAAEd,IAAEe,KAAE,EAAEZ,EAAC,GAAEa,KAAEL,OAAII,OAAIT,MAAG,CAACO,KAAE,CAAC,EAAEP,EAAC,CAAC,IAAE,SAASW,IAAE;AAAC,YAAMjB,KAAE,EAAEiB,EAAC;AAAE,aAAM,CAAC,EAAEA,EAAC,GAAEjB,IAAE,EAAEA,EAAC,CAAC;AAAA,IAAC,EAAEM,EAAC,IAAGY,KAAE,CAACZ,IAAE,GAAGU,EAAC,GAAEG,KAAE,MAAM,EAAElB,IAAEa,EAAC,GAAEM,KAAE,CAAC;AAAE,QAAIC,MAAG,SAAOnB,KAAEE,GAAE,QAAM,SAAOF,GAAE,cAAY,CAAC;AAAE,QAAGO,MAAGW,GAAE,KAAKD,GAAEJ,GAAE,GAAEL,IAAE;AAAC,YAAK,EAAC,MAAKO,IAAE,OAAMjB,GAAC,IAAE,EAAEG,IAAEE,IAAE,OAAM,QAAME,GAAE,QAAM,SAAOA,GAAE,MAAMC,GAAE,QAAQ,EAAE;AAAE,MAAAY,GAAE,KAAKD,GAAEF,KAAGE,GAAEnB,GAAE;AAAA,IAAC;AAAC,QAAGqB,KAAE,CAAC,GAAGA,IAAE,EAAC,WAAUlB,IAAE,WAAUiB,GAAC,CAAC,GAAE,CAACA,GAAE,MAAO,CAAAH,OAAGA,MAAG,CAAE,GAAE;AAAC,UAAIK,IAAEC;AAAE,YAAMN,MAAG,SAAOK,KAAE,SAAOC,KAAEnB,GAAE,QAAM,SAAOmB,GAAE,SAAOD,KAAE,KAAG,GAAEtB,KAAEkB,GAAED;AAAG,UAAGjB;AAAE,eAAM,EAAC,MAAK,EAAC,OAAMiB,IAAE,WAAUI,GAAC,GAAE,OAAM,EAAC,WAAUrB,GAAC,EAAC;AAAE,UAAIC,KAAE;AAAS,cAAOW,IAAE;AAAA,QAAC,KAAI,WAAU;AAAC,cAAIY;AAAE,gBAAMP,KAAE,SAAOO,KAAEH,GAAE,IAAK,CAAAJ,OAAG,CAACA,IAAEA,GAAE,UAAU,OAAQ,CAAAA,OAAGA,KAAE,CAAE,EAAE,OAAQ,CAACA,IAAEjB,OAAIiB,KAAEjB,IAAG,CAAC,CAAC,CAAE,EAAE,KAAM,CAACiB,IAAEjB,OAAIiB,GAAE,KAAGjB,GAAE,EAAG,EAAE,MAAI,SAAOwB,GAAE,GAAG;AAAU,UAAAP,OAAIhB,KAAEgB;AAAG;AAAA,QAAK;AAAA,QAAC,KAAI;AAAmB,UAAAhB,KAAEK;AAAA,MAAC;AAAC,UAAGH,OAAIF;AAAE,eAAM,EAAC,OAAM,EAAC,WAAUA,GAAC,EAAC;AAAA,IAAC;AAAC,WAAM,CAAC;AAAA,EAAC,EAAC;AAAC;AAA+jB,IAAM,IAAE,SAASwB,IAAE;AAAC,SAAO,WAASA,OAAIA,KAAE,IAAG,EAAC,MAAK,UAAS,SAAQA,IAAE,MAAM,GAAGC,IAAE;AAAC,UAAK,EAAC,GAAEC,IAAE,GAAEC,GAAC,IAAEF,IAAEG,KAAE,MAAM,eAAeJ,IAAEC,IAAE;AAAC,YAAK,EAAC,WAAUC,IAAE,UAASC,IAAE,UAASC,GAAC,IAAEJ,IAAEK,KAAE,OAAM,QAAMF,GAAE,QAAM,SAAOA,GAAE,MAAMC,GAAE,QAAQ,IAAGE,KAAE,EAAEJ,EAAC,GAAEK,KAAE,EAAEL,EAAC,GAAEM,KAAE,QAAM,EAAEN,EAAC,GAAEO,KAAE,CAAC,QAAO,KAAK,EAAE,SAASH,EAAC,IAAE,KAAG,GAAEI,KAAEL,MAAGG,KAAE,KAAG,GAAEG,KAAE,cAAY,OAAOV,KAAEA,GAAED,EAAC,IAAEC;AAAE,UAAG,EAAC,UAASW,IAAE,WAAUC,IAAE,eAAcC,GAAC,IAAE,YAAU,OAAOH,KAAE,EAAC,UAASA,IAAE,WAAU,GAAE,eAAc,KAAI,IAAE,EAAC,UAAS,GAAE,WAAU,GAAE,eAAc,MAAK,GAAGA,GAAC;AAAE,aAAOJ,MAAG,YAAU,OAAOO,OAAID,KAAE,UAAQN,KAAE,KAAGO,KAAEA,KAAGN,KAAE,EAAC,GAAEK,KAAEH,IAAE,GAAEE,KAAEH,GAAC,IAAE,EAAC,GAAEG,KAAEH,IAAE,GAAEI,KAAEH,GAAC;AAAA,IAAC,EAAET,IAAED,EAAC;AAAE,WAAM,EAAC,GAAEE,KAAEE,GAAE,GAAE,GAAED,KAAEC,GAAE,GAAE,MAAKA,GAAC;AAAA,EAAC,EAAC;AAAC;AAAE,SAAS,EAAEW,IAAE;AAAC,SAAM,QAAMA,KAAE,MAAI;AAAG;AAAC,IAAM,IAAE,SAASC,IAAE;AAAC,SAAO,WAASA,OAAIA,KAAE,CAAC,IAAG,EAAC,MAAK,SAAQ,SAAQA,IAAE,MAAM,GAAGhB,IAAE;AAAC,UAAK,EAAC,GAAEC,IAAE,GAAEC,IAAE,WAAUC,GAAC,IAAEH,IAAE,EAAC,UAASI,KAAE,MAAG,WAAUE,KAAE,OAAG,SAAQC,KAAE,EAAC,IAAG,CAAAQ,OAAG;AAAC,UAAG,EAAC,GAAEC,IAAE,GAAEC,GAAC,IAAEF;AAAE,aAAM,EAAC,GAAEC,IAAE,GAAEC,GAAC;AAAA,IAAC,EAAC,MAAKR,GAAC,IAAEO,IAAEN,KAAE,EAAC,GAAET,IAAE,GAAEC,GAAC,GAAES,KAAE,MAAM,EAAEX,IAAES,EAAC,GAAEG,KAAE,EAAE,EAAET,EAAC,CAAC,GAAEU,KAAE,EAAED,EAAC;AAAE,QAAIE,KAAEJ,GAAEE,KAAGM,KAAER,GAAEG;AAAG,QAAGT,IAAE;AAAC,YAAMW,KAAE,QAAMH,KAAE,WAAS;AAAQ,MAAAE,KAAE,EAAEA,KAAEH,GAAE,QAAMC,KAAE,QAAM,SAAQE,IAAEA,KAAEH,GAAEI,GAAE;AAAA,IAAC;AAAC,QAAGT,IAAE;AAAC,YAAMS,KAAE,QAAMF,KAAE,WAAS;AAAQ,MAAAK,KAAE,EAAEA,KAAEP,GAAE,QAAME,KAAE,QAAM,SAAQK,IAAEA,KAAEP,GAAEI,GAAE;AAAA,IAAC;AAAC,UAAMI,KAAEZ,GAAE,GAAG,EAAC,GAAGP,IAAE,CAACY,KAAGE,IAAE,CAACD,KAAGK,GAAC,CAAC;AAAE,WAAM,EAAC,GAAGC,IAAE,MAAK,EAAC,GAAEA,GAAE,IAAElB,IAAE,GAAEkB,GAAE,IAAEjB,GAAC,EAAC;AAAA,EAAC,EAAC;AAAC;;;ACAlsO,SAASkB,GAAEC,IAAE;AAAC,SAAOA,MAAGA,GAAE,YAAUA,GAAE,YAAUA,GAAE,SAAOA,GAAE;AAAW;AAAC,SAASC,GAAED,IAAE;AAAC,MAAG,QAAMA;AAAE,WAAO;AAAO,MAAG,CAACD,GAAEC,EAAC,GAAE;AAAC,UAAME,KAAEF,GAAE;AAAc,WAAOE,MAAGA,GAAE,eAAa;AAAA,EAAM;AAAC,SAAOF;AAAC;AAAC,SAASG,GAAEH,IAAE;AAAC,SAAOC,GAAED,EAAC,EAAE,iBAAiBA,EAAC;AAAC;AAAC,SAASI,GAAEJ,IAAE;AAAC,SAAOD,GAAEC,EAAC,IAAE,KAAGA,MAAGA,GAAE,YAAU,IAAI,YAAY,IAAE;AAAE;AAAC,SAASK,KAAG;AAAC,QAAML,KAAE,UAAU;AAAc,SAAO,QAAMA,MAAGA,GAAE,SAAOA,GAAE,OAAO,IAAK,CAAAA,OAAGA,GAAE,QAAM,MAAIA,GAAE,OAAQ,EAAE,KAAK,GAAG,IAAE,UAAU;AAAS;AAAC,SAASM,GAAEN,IAAE;AAAC,SAAOA,cAAaC,GAAED,EAAC,EAAE;AAAW;AAAC,SAASO,GAAEP,IAAE;AAAC,SAAOA,cAAaC,GAAED,EAAC,EAAE;AAAO;AAAC,SAASQ,GAAER,IAAE;AAAC,MAAG,eAAa,OAAO;AAAW,WAAM;AAAG,SAAOA,cAAaC,GAAED,EAAC,EAAE,cAAYA,cAAa;AAAU;AAAC,SAASS,GAAET,IAAE;AAAC,QAAK,EAAC,UAASE,IAAE,WAAUH,IAAE,WAAUE,IAAE,SAAQG,GAAC,IAAED,GAAEH,EAAC;AAAE,SAAM,6BAA6B,KAAKE,KAAED,KAAEF,EAAC,KAAG,CAAC,CAAC,UAAS,UAAU,EAAE,SAASK,EAAC;AAAC;AAAC,SAASM,GAAEV,IAAE;AAAC,SAAM,CAAC,SAAQ,MAAK,IAAI,EAAE,SAASI,GAAEJ,EAAC,CAAC;AAAC;AAAC,SAASW,GAAEX,IAAE;AAAC,QAAME,KAAE,WAAW,KAAKG,GAAE,CAAC,GAAEN,KAAEI,GAAEH,EAAC;AAAE,SAAM,WAASD,GAAE,aAAW,WAASA,GAAE,eAAaG,MAAG,aAAWH,GAAE,cAAYG,MAAG,CAAC,CAACH,GAAE,UAAQ,WAASA,GAAE,UAAQ,CAAC,aAAY,aAAa,EAAE,KAAM,CAAAC,OAAGD,GAAE,WAAW,SAASC,EAAC,CAAE,KAAG,CAAC,SAAQ,UAAS,UAAS,SAAS,EAAE,KAAM,CAAAA,OAAG;AAAC,UAAME,KAAEH,GAAE;AAAQ,WAAO,QAAMG,MAAGA,GAAE,SAASF,EAAC;AAAA,EAAC,CAAE;AAAC;AAAC,SAASY,KAAG;AAAC,SAAM,CAAC,iCAAiC,KAAKP,GAAE,CAAC;AAAC;AAAC,SAASQ,GAAEb,IAAE;AAAC,SAAM,CAAC,QAAO,QAAO,WAAW,EAAE,SAASI,GAAEJ,EAAC,CAAC;AAAC;AAAC,IAAMc,KAAE,KAAK;AAAb,IAAiBC,KAAE,KAAK;AAAxB,IAA4BC,KAAE,KAAK;AAAM,SAASC,GAAEjB,IAAEE,IAAEH,IAAE;AAAC,MAAII,IAAEC,IAAEC,IAAEG;AAAE,aAASN,OAAIA,KAAE,QAAI,WAASH,OAAIA,KAAE;AAAI,QAAMU,KAAET,GAAE,sBAAsB;AAAE,MAAIU,KAAE,GAAEC,KAAE;AAAE,EAAAT,MAAGI,GAAEN,EAAC,MAAIU,KAAEV,GAAE,cAAY,KAAGgB,GAAEP,GAAE,KAAK,IAAET,GAAE,eAAa,GAAEW,KAAEX,GAAE,eAAa,KAAGgB,GAAEP,GAAE,MAAM,IAAET,GAAE,gBAAc;AAAG,QAAMa,KAAEN,GAAEP,EAAC,IAAEC,GAAED,EAAC,IAAE,QAAOc,KAAE,CAACF,GAAE,KAAGb,IAAEgB,MAAGN,GAAE,QAAMK,MAAG,SAAOX,KAAE,SAAOC,KAAES,GAAE,kBAAgB,SAAOT,GAAE,cAAYD,KAAE,MAAIO,IAAEO,MAAGR,GAAE,OAAKK,MAAG,SAAOT,KAAE,SAAOG,KAAEK,GAAE,kBAAgB,SAAOL,GAAE,aAAWH,KAAE,MAAIM,IAAEO,KAAET,GAAE,QAAMC,IAAES,KAAEV,GAAE,SAAOE;AAAE,SAAM,EAAC,OAAMO,IAAE,QAAOC,IAAE,KAAIF,IAAE,OAAMF,KAAEG,IAAE,QAAOD,KAAEE,IAAE,MAAKJ,IAAE,GAAEA,IAAE,GAAEE,GAAC;AAAC;AAAC,SAASC,GAAElB,IAAE;AAAC,UAAOE,KAAEF,KAAGE,cAAaD,GAAEC,EAAC,EAAE,OAAKF,GAAE,gBAAcA,GAAE,aAAW,OAAO,UAAU;AAAgB,MAAIE;AAAC;AAAC,SAASiB,GAAEnB,IAAE;AAAC,SAAOO,GAAEP,EAAC,IAAE,EAAC,YAAWA,GAAE,YAAW,WAAUA,GAAE,UAAS,IAAE,EAAC,YAAWA,GAAE,aAAY,WAAUA,GAAE,YAAW;AAAC;AAAC,SAASoB,GAAEpB,IAAE;AAAC,SAAOiB,GAAEC,GAAElB,EAAC,CAAC,EAAE,OAAKmB,GAAEnB,EAAC,EAAE;AAAU;AAAC,SAASqB,GAAErB,IAAEE,IAAEH,IAAE;AAAC,QAAME,KAAEK,GAAEJ,EAAC,GAAEC,KAAEe,GAAEhB,EAAC,GAAEG,KAAEY,GAAEjB,IAAEC,MAAG,SAASD,IAAE;AAAC,UAAME,KAAEe,GAAEjB,EAAC;AAAE,WAAOgB,GAAEd,GAAE,KAAK,MAAIF,GAAE,eAAagB,GAAEd,GAAE,MAAM,MAAIF,GAAE;AAAA,EAAY,EAAEE,EAAC,GAAE,YAAUH,EAAC;AAAE,MAAIQ,KAAE,EAAC,YAAW,GAAE,WAAU,EAAC;AAAE,QAAMC,KAAE,EAAC,GAAE,GAAE,GAAE,EAAC;AAAE,MAAGP,MAAG,CAACA,MAAG,YAAUF;AAAE,SAAI,WAASK,GAAEF,EAAC,KAAGO,GAAEN,EAAC,OAAKI,KAAEY,GAAEjB,EAAC,IAAGI,GAAEJ,EAAC,GAAE;AAAC,YAAMF,KAAEiB,GAAEf,IAAE,IAAE;AAAE,MAAAM,GAAE,IAAER,GAAE,IAAEE,GAAE,YAAWM,GAAE,IAAER,GAAE,IAAEE,GAAE;AAAA,IAAS;AAAM,MAAAC,OAAIK,GAAE,IAAEY,GAAEjB,EAAC;AAAG,SAAM,EAAC,GAAEE,GAAE,OAAKE,GAAE,aAAWC,GAAE,GAAE,GAAEH,GAAE,MAAIE,GAAE,YAAUC,GAAE,GAAE,OAAMH,GAAE,OAAM,QAAOA,GAAE,OAAM;AAAC;AAAC,SAAS,EAAEL,IAAE;AAAC,SAAM,WAASI,GAAEJ,EAAC,IAAEA,KAAEA,GAAE,gBAAcA,GAAE,eAAaQ,GAAER,EAAC,IAAEA,GAAE,OAAK,SAAOkB,GAAElB,EAAC;AAAC;AAAC,SAASsB,GAAEtB,IAAE;AAAC,SAAOM,GAAEN,EAAC,KAAG,YAAUG,GAAEH,EAAC,EAAE,WAASA,GAAE,eAAa;AAAI;AAAC,SAASuB,GAAEvB,IAAE;AAAC,QAAME,KAAED,GAAED,EAAC;AAAE,MAAID,KAAEuB,GAAEtB,EAAC;AAAE,SAAKD,MAAGW,GAAEX,EAAC,KAAG,aAAWI,GAAEJ,EAAC,EAAE;AAAU,IAAAA,KAAEuB,GAAEvB,EAAC;AAAE,SAAOA,OAAI,WAASK,GAAEL,EAAC,KAAG,WAASK,GAAEL,EAAC,KAAG,aAAWI,GAAEJ,EAAC,EAAE,YAAU,CAACY,GAAEZ,EAAC,KAAGG,KAAEH,MAAG,SAASC,IAAE;AAAC,QAAIE,KAAE,EAAEF,EAAC;AAAE,SAAIQ,GAAEN,EAAC,MAAIA,KAAEA,GAAE,OAAMI,GAAEJ,EAAC,KAAG,CAACW,GAAEX,EAAC,KAAG;AAAC,UAAGS,GAAET,EAAC;AAAE,eAAOA;AAAE;AAAC,cAAMF,KAAEE,GAAE;AAAW,QAAAA,KAAEM,GAAER,EAAC,IAAEA,GAAE,OAAKA;AAAA,MAAC;AAAA,IAAC;AAAC,WAAO;AAAA,EAAI,EAAEA,EAAC,KAAGE;AAAC;AAAC,SAAS,EAAEF,IAAE;AAAC,MAAGM,GAAEN,EAAC;AAAE,WAAM,EAAC,OAAMA,GAAE,aAAY,QAAOA,GAAE,aAAY;AAAE,QAAME,KAAEe,GAAEjB,EAAC;AAAE,SAAM,EAAC,OAAME,GAAE,OAAM,QAAOA,GAAE,OAAM;AAAC;AAAC,SAAS,EAAEF,IAAE;AAAC,QAAME,KAAE,EAAEF,EAAC;AAAE,SAAOa,GAAEX,EAAC,IAAEF,GAAE,cAAc,OAAKM,GAAEJ,EAAC,KAAGO,GAAEP,EAAC,IAAEA,KAAE,EAAEA,EAAC;AAAC;AAAC,SAAS,EAAEF,IAAEE,IAAE;AAAC,MAAIH;AAAE,aAASG,OAAIA,KAAE,CAAC;AAAG,QAAMC,KAAE,EAAEH,EAAC,GAAEI,KAAED,QAAK,SAAOJ,KAAEC,GAAE,iBAAe,SAAOD,GAAE,OAAMM,KAAEJ,GAAEE,EAAC,GAAEG,KAAEF,KAAE,CAACC,EAAC,EAAE,OAAOA,GAAE,kBAAgB,CAAC,GAAEI,GAAEN,EAAC,IAAEA,KAAE,CAAC,CAAC,IAAEA,IAAEI,KAAEL,GAAE,OAAOI,EAAC;AAAE,SAAOF,KAAEG,KAAEA,GAAE,OAAO,EAAED,EAAC,CAAC;AAAC;AAAC,SAASkB,GAAEtB,IAAEH,IAAEK,IAAE;AAAC,SAAM,eAAaL,KAAE,EAAE,SAASC,IAAEE,IAAE;AAAC,UAAMH,KAAEE,GAAED,EAAC,GAAEG,KAAEe,GAAElB,EAAC,GAAEI,KAAEL,GAAE;AAAe,QAAIM,KAAEF,GAAE,aAAYG,KAAEH,GAAE,cAAaI,KAAE,GAAEC,KAAE;AAAE,QAAGJ,IAAE;AAAC,MAAAC,KAAED,GAAE,OAAME,KAAEF,GAAE;AAAO,YAAMJ,KAAEY,GAAE;AAAE,OAACZ,MAAG,CAACA,MAAG,YAAUE,QAAKK,KAAEH,GAAE,YAAWI,KAAEJ,GAAE;AAAA,IAAU;AAAC,WAAM,EAAC,OAAMC,IAAE,QAAOC,IAAE,GAAEC,IAAE,GAAEC,GAAC;AAAA,EAAC,EAAEN,IAAEE,EAAC,CAAC,IAAEG,GAAER,EAAC,IAAE,SAASC,IAAEE,IAAE;AAAC,UAAMH,KAAEkB,GAAEjB,IAAE,OAAG,YAAUE,EAAC,GAAED,KAAEF,GAAE,MAAIC,GAAE,WAAUG,KAAEJ,GAAE,OAAKC,GAAE;AAAW,WAAM,EAAC,KAAIC,IAAE,MAAKE,IAAE,GAAEA,IAAE,GAAEF,IAAE,OAAME,KAAEH,GAAE,aAAY,QAAOC,KAAED,GAAE,cAAa,OAAMA,GAAE,aAAY,QAAOA,GAAE,aAAY;AAAA,EAAC,EAAED,IAAEK,EAAC,IAAE,EAAE,SAASJ,IAAE;AAAC,QAAIE;AAAE,UAAMH,KAAEmB,GAAElB,EAAC,GAAEC,KAAEkB,GAAEnB,EAAC,GAAEI,KAAE,SAAOF,KAAEF,GAAE,iBAAe,SAAOE,GAAE,MAAKG,KAAEU,GAAEhB,GAAE,aAAYA,GAAE,aAAYK,KAAEA,GAAE,cAAY,GAAEA,KAAEA,GAAE,cAAY,CAAC,GAAEE,KAAES,GAAEhB,GAAE,cAAaA,GAAE,cAAaK,KAAEA,GAAE,eAAa,GAAEA,KAAEA,GAAE,eAAa,CAAC;AAAE,QAAIG,KAAE,CAACN,GAAE,aAAWmB,GAAEpB,EAAC;AAAE,UAAMQ,KAAE,CAACP,GAAE;AAAU,WAAM,UAAQE,GAAEC,MAAGL,EAAC,EAAE,cAAYQ,MAAGQ,GAAEhB,GAAE,aAAYK,KAAEA,GAAE,cAAY,CAAC,IAAEC,KAAG,EAAC,OAAMA,IAAE,QAAOC,IAAE,GAAEC,IAAE,GAAEC,GAAC;AAAA,EAAC,EAAEU,GAAEhB,EAAC,CAAC,CAAC;AAAC;AAAC,SAAS,EAAEF,IAAE;AAAC,QAAME,KAAE,EAAEF,EAAC,GAAED,KAAE,SAASC,IAAEE,IAAE;AAAC,QAAIH,KAAEC;AAAE,WAAKD,MAAG,CAACc,GAAEd,EAAC,KAAG,CAACG,GAAE,SAASH,EAAC,MAAI,CAACQ,GAAER,EAAC,KAAG,CAAC,CAAC,YAAW,OAAO,EAAE,SAASI,GAAEJ,EAAC,EAAE,QAAQ,MAAI;AAAC,YAAMC,KAAE,EAAED,EAAC;AAAE,MAAAA,KAAES,GAAER,EAAC,IAAEA,GAAE,OAAKA;AAAA,IAAC;AAAC,WAAOD;AAAA,EAAC,EAAEC,IAAEE,EAAC;AAAE,MAAID,KAAE;AAAK,MAAGF,MAAGO,GAAEP,EAAC,GAAE;AAAC,UAAMC,KAAEuB,GAAExB,EAAC;AAAE,IAAAU,GAAEV,EAAC,IAAEE,KAAEF,KAAEO,GAAEN,EAAC,MAAIC,KAAED;AAAA,EAAE;AAAC,SAAOO,GAAEN,EAAC,IAAEC,GAAE,OAAQ,CAAAF,OAAGC,MAAGM,GAAEP,EAAC,KAAG,SAASA,IAAEE,IAAE;AAAC,UAAMH,KAAE,QAAMG,GAAE,cAAY,SAAOA,GAAE,YAAY;AAAE,QAAGF,GAAE,SAASE,EAAC;AAAE,aAAM;AAAG,QAAGH,MAAGS,GAAET,EAAC,GAAE;AAAC,UAAIA,KAAEG;AAAE,SAAE;AAAC,YAAGH,MAAGC,OAAID;AAAE,iBAAM;AAAG,QAAAA,KAAEA,GAAE,cAAYA,GAAE;AAAA,MAAI,SAAOA;AAAA,IAAE;AAAC,WAAM;AAAA,EAAE,EAAEC,IAAEC,EAAC,KAAG,WAASG,GAAEJ,EAAC,CAAE,IAAE,CAAC;AAAC;AAAC,IAAM,IAAE,EAAC,iBAAgB,SAASA,IAAE;AAAC,MAAG,EAAC,SAAQE,IAAE,UAASH,IAAE,cAAaE,IAAE,UAASE,GAAC,IAAEH;AAAE,QAAMI,KAAE,CAAC,GAAG,wBAAsBL,KAAE,EAAEG,EAAC,IAAE,CAAC,EAAE,OAAOH,EAAC,GAAEE,EAAC,GAAEI,KAAED,GAAE,IAAGE,KAAEF,GAAE,OAAQ,CAACJ,IAAED,OAAI;AAAC,UAAME,KAAEuB,GAAEtB,IAAEH,IAAEI,EAAC;AAAE,WAAOH,GAAE,MAAIe,GAAEd,GAAE,KAAID,GAAE,GAAG,GAAEA,GAAE,QAAMc,GAAEb,GAAE,OAAMD,GAAE,KAAK,GAAEA,GAAE,SAAOc,GAAEb,GAAE,QAAOD,GAAE,MAAM,GAAEA,GAAE,OAAKe,GAAEd,GAAE,MAAKD,GAAE,IAAI,GAAEA;AAAA,EAAC,GAAGwB,GAAEtB,IAAEG,IAAEF,EAAC,CAAC;AAAE,SAAM,EAAC,OAAMG,GAAE,QAAMA,GAAE,MAAK,QAAOA,GAAE,SAAOA,GAAE,KAAI,GAAEA,GAAE,MAAK,GAAEA,GAAE,IAAG;AAAC,GAAE,uDAAsD,SAASN,IAAE;AAAC,MAAG,EAAC,MAAKE,IAAE,cAAaH,IAAE,UAASE,GAAC,IAAED;AAAE,QAAMG,KAAEG,GAAEP,EAAC,GAAEM,KAAEa,GAAEnB,EAAC;AAAE,MAAGA,OAAIM;AAAE,WAAOH;AAAE,MAAIK,KAAE,EAAC,YAAW,GAAE,WAAU,EAAC;AAAE,QAAMC,KAAE,EAAC,GAAE,GAAE,GAAE,EAAC;AAAE,OAAIL,MAAG,CAACA,MAAG,YAAUF,SAAM,WAASG,GAAEL,EAAC,KAAGU,GAAEJ,EAAC,OAAKE,KAAEY,GAAEpB,EAAC,IAAGO,GAAEP,EAAC,IAAG;AAAC,UAAMC,KAAEiB,GAAElB,IAAE,IAAE;AAAE,IAAAS,GAAE,IAAER,GAAE,IAAED,GAAE,YAAWS,GAAE,IAAER,GAAE,IAAED,GAAE;AAAA,EAAS;AAAC,SAAM,EAAC,GAAGG,IAAE,GAAEA,GAAE,IAAEK,GAAE,aAAWC,GAAE,GAAE,GAAEN,GAAE,IAAEK,GAAE,YAAUC,GAAE,EAAC;AAAC,GAAE,WAAUD,IAAE,eAAc,GAAE,iBAAgBgB,IAAE,oBAAmBL,IAAE,iBAAgB,CAAAlB,OAAG;AAAC,MAAG,EAAC,WAAUE,IAAE,UAASH,IAAE,UAASE,GAAC,IAAED;AAAE,SAAM,EAAC,WAAUqB,GAAEnB,IAAEqB,GAAExB,EAAC,GAAEE,EAAC,GAAE,UAAS,EAAC,GAAG,EAAEF,EAAC,GAAE,GAAE,GAAE,GAAE,EAAC,EAAC;AAAC,GAAE,gBAAe,CAAAC,OAAG,MAAM,KAAKA,GAAE,eAAe,CAAC,GAAE,OAAM,CAAAA,OAAG,UAAQG,GAAEH,EAAC,EAAE,UAAS;AAAE,SAAS,EAAEA,IAAEE,IAAEH,IAAEE,IAAE;AAAC,aAASA,OAAIA,KAAE,CAAC;AAAG,QAAK,EAAC,gBAAeE,KAAE,MAAG,gBAAeC,KAAE,MAAG,eAAcC,KAAE,MAAG,gBAAeC,KAAE,MAAE,IAAEL,IAAEO,KAAEL,MAAG,CAACG,IAAEG,KAAED,MAAGJ,KAAE,CAAC,GAAGG,GAAEP,EAAC,IAAE,EAAEA,EAAC,IAAEA,GAAE,iBAAe,EAAEA,GAAE,cAAc,IAAE,CAAC,GAAE,GAAG,EAAEE,EAAC,CAAC,IAAE,CAAC;AAAE,EAAAO,GAAE,QAAS,CAAAT,OAAG;AAAC,IAAAQ,MAAGR,GAAE,iBAAiB,UAASD,IAAE,EAAC,SAAQ,KAAE,CAAC,GAAEK,MAAGJ,GAAE,iBAAiB,UAASD,EAAC;AAAA,EAAC,CAAE;AAAE,MAAIW,IAAEC,KAAE;AAAK,MAAGN,IAAE;AAAC,QAAIJ,KAAE;AAAG,IAAAU,KAAE,IAAI,eAAgB,MAAI;AAAC,MAAAV,MAAGF,GAAE,GAAEE,KAAE;AAAA,IAAE,CAAE,GAAEM,GAAEP,EAAC,KAAG,CAACM,MAAGK,GAAE,QAAQX,EAAC,GAAEO,GAAEP,EAAC,KAAG,CAACA,GAAE,kBAAgBM,MAAGK,GAAE,QAAQX,GAAE,cAAc,GAAEW,GAAE,QAAQT,EAAC;AAAA,EAAC;AAAC,MAAIU,KAAEN,KAAEW,GAAEjB,EAAC,IAAE;AAAK,SAAOM,MAAG,SAASJ,KAAG;AAAC,UAAMD,KAAEgB,GAAEjB,EAAC;AAAE,KAACY,MAAGX,GAAE,MAAIW,GAAE,KAAGX,GAAE,MAAIW,GAAE,KAAGX,GAAE,UAAQW,GAAE,SAAOX,GAAE,WAASW,GAAE,UAAQb,GAAE;AAAE,IAAAa,KAAEX,IAAES,KAAE,sBAAsBR,EAAC;AAAA,EAAC,EAAE,GAAEH,GAAE,GAAE,MAAI;AAAC,QAAIC;AAAE,IAAAS,GAAE,QAAS,CAAAT,OAAG;AAAC,MAAAQ,MAAGR,GAAE,oBAAoB,UAASD,EAAC,GAAEK,MAAGJ,GAAE,oBAAoB,UAASD,EAAC;AAAA,IAAC,CAAE,GAAE,SAAOC,KAAEW,OAAIX,GAAE,WAAW,GAAEW,KAAE,MAAKL,MAAG,qBAAqBI,EAAC;AAAA,EAAC;AAAC;AAAC,IAAM,IAAE,CAACV,IAAED,IAAEE,OAAI,EAAED,IAAED,IAAE,EAAC,UAAS,GAAE,GAAGE,GAAC,CAAC;;;ACcjrN,IAAM,kBAAN,cAA8B,eAAe;AAAA,EAiB3C,oBAAoB;AAClB,UAAM,SAAS,SAAS,cAA2B,KAAK,QAAQ,MAAO;AACvE,QAAI,CAAC;AAAQ,YAAM,IAAI,MAAM,8CAA8C;AAE3E,SAAK,SAAS;AACd,SAAK,aAAa,KAAK,gBAAgB;AACvC,SAAK,MAAM;AAAA,EACb;AAAA,EAEA,uBAAuB;AAxCzB;AAyCI,eAAK,YAAL;AAAA,EACF;AAAA,EAEQ,kBAAkB;AACxB,UAAM,aAA2B,CAAC;AAClC,QAAI,KAAK;AAAQ,iBAAW,KAAK,EAAO,KAAK,MAAM,CAAC;AACpD,QAAI,KAAK;AAAO,iBAAW,KAAK,EAAM,EAAE,cAAc,WAAW,CAAC,CAAC;AACnE,QAAI,KAAK;AAAM,iBAAW,KAAK,EAAK,CAAC;AACrC,QAAI,KAAK;AAAO,iBAAW,KAAK,EAAM,EAAE,SAAS,KAAK,MAAM,CAAC,CAAC;AAC9D,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ;AACN,SAAK,UAAU,EAAW,KAAK,QAAQ,MAAM,KAAK,OAAO,KAAK,IAAI,CAAC;AAAA,EACrE;AAAA,EAEA,SAAS;AACP,QAAI,CAAC,UAAU,IAAI;AAAG;AACtB,MAAgB,KAAK,QAAQ,MAAM;AAAA,MACjC,WAAW,KAAK;AAAA,MAChB,YAAY,KAAK;AAAA,IACnB,CAAC,EAAE,KAAK,CAAC,EAAE,GAAAwB,IAAG,GAAAC,IAAG,WAAW,eAAe,MAAM;AAC/C,aAAO,OAAO,KAAK,OAAO;AAAA,QACxB,MAAM,GAAGD;AAAA,QACT,KAAK,GAAGC;AAAA,MACV,CAAC;AAED,UAAI,eAAe,SAAS,KAAK,OAAO;AACtC,cAAM,EAAE,GAAG,QAAQ,GAAG,OAAO,IAAI,eAAe;AAEhD,cAAM,aAAa;AAAA,UACjB,KAAK;AAAA,UACL,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,MAAM;AAAA,QACR,EAAE,UAAU,MAAM,GAAG,EAAE;AAEvB,eAAO,OAAO,KAAK,MAAM,OAAO;AAAA,UAC9B,MAAM,UAAU,OAAO,GAAG,aAAa;AAAA,UACvC,KAAK,UAAU,OAAO,GAAG,aAAa;AAAA,UACtC,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,CAAC,aAAa;AAAA,QAChB,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAvEE;AAAA,EADC,MAAM,OAAO;AAAA,GAFV,gBAGJ;AAGA;AAAA,EADC,KAAK,gBAAgB;AAAA,GALlB,gBAMJ;AAEA;AAAA,EADC,KAAK,eAAe,MAAM;AAAA,GAPvB,gBAQJ;AAEA;AAAA,EADC,KAAK,cAAc,QAAQ;AAAA,GATxB,gBAUJ;AAEA;AAAA,EADC,KAAK,aAAa,QAAQ;AAAA,GAXvB,gBAYJ;AAgEF,IAAM,WAAiC,OAAO;AAAA,EAC5C,MAAM,MAAM;AACV,mBAAe,OAAO,oBAAoB,iBAAiB,EAAE,SAAS,MAAM,CAAC;AAAA,EAC/E;AAAA,EACA,iBAAiB,CAAC,MAAM,OAAO;AAC7B,QAAI,KAAK,aAAa,IAAI,MAAM,oBAAoB;AAClD,SAAG,aAAa,SAAS,KAAK,aAAa,OAAO,CAAE;AAAA,IACtD;AAAA,EACF;AACF;AAEA,IAAO,mBAAQ;;;AC7Ff,IAAM,iBAAN,cAA6B,cAAc;AAAA,EAA3C;AAAA;AAOE,SAAQ,YAAY,IAAI,YAAY;AAAA;AAAA,EAEpC,WAAW,qBAAqB;AAC9B,WAAO,CAAC,YAAY;AAAA,EACtB;AAAA,EAEA,oBAAoB;AAClB,QAAI,CAAC,KAAK,SAAS,CAAC,KAAK;AACvB,YAAM,IAAI,MAAM,0DAA0D;AAE5E,SAAK,UAAU,iBAAiB,KAAK,SAAS,SAAS,MAAM;AAC3D,WAAK,aAAa,SAAS,KAAK,KAAK,CAAC;AAAA,IACxC,CAAC;AAED,SAAK,QAAQ,IAAI,MAAM,KAAK,OAAO;AAAA,MACjC,eAAe;AAAA,MACf,cAAc,SAAS,KAAK,QAAQ,UAAU;AAAA,MAC9C,oBAAoB,SAAS,KAAK,QAAQ,gBAAgB;AAAA,IAC5D,CAAC;AAAA,EACH;AAAA,EAEA,gBAAgB,WAAmB,WAAoB,WAAoB;AACzE,QAAI,cAAc;AAAc,WAAK,kBAAkB;AAAA,EACzD;AAAA,EAEA,uBAAuB;AACrB,SAAK,UAAU,QAAQ;AAAA,EACzB;AAAA,EAEM,oBAAoB;AAAA;AACxB,UAAI,KAAK,UAAU,QAAQ;AACzB,aAAK,UAAU,MAAM,KAAK,QAAQ,QAAQ;AAE1C,aAAK,MAAM,kBAAkB,MAAM;AACjC,eAAK,aAAa,QAAQ;AAAA,QAC5B,CAAC;AAID,cAAMC,KAAI,IAAI,YAAY;AAC1B,QAAAA,GAAE,UAAU,MAAM;AAChB,eAAK,oBAAoB,KAAK,OAAO,QAAQ;AAC7C,eAAK,iBAAiB,KAAK,SAAS,iBAAiB,MAAM;AAC3D,4BAAkB,KAAK,OAAO,OAAO;AAAA,QACvC,CAAC;AAAA,MACH,OAAO;AACL,aAAK,UAAU,MAAM,KAAK,QAAQ,SAAS;AAE3C,aAAK,MAAM,qBAAqB;AAChC,cAAM,kBAAkB,KAAK,OAAO,OAAO;AAC3C,aAAK,iBAAiB,KAAK,OAAO,UAAU,MAAM;AAClD,aAAK,iBAAiB,KAAK,SAAS,iBAAiB,OAAO;AAAA,MAC9D;AAAA,IACF;AAAA;AACF;AA3DE;AAAA,EADC,MAAM,SAAS;AAAA,GADZ,eAEJ;AAEA;AAAA,EADC,MAAM,OAAO;AAAA,GAHV,eAIJ;AA2DF,IAAM,UAAgC,OAAO;AAAA,EAC3C,MAAM,MAAM;AACV,mBAAe,OAAO,cAAc,cAAc;AAAA,EACpD;AACF;AAEA,IAAO,kBAAQ;;;ACvEf,IAAM,iBAAN,cAA6B,cAAc;AAAA,EAA3C;AAAA;AAWE,SAAQ,cAAc,IAAI,YAAY;AACtC,SAAQ,YAAY,IAAI,YAAY;AAAA;AAAA,EAEpC,WAAW,qBAAqB;AAC9B,WAAO,CAAC,YAAY;AAAA,EACtB;AAAA,EAEA,oBAAoB;AAClB,QAAI,CAAC,KAAK,aAAa,CAAC,KAAK;AAC3B,YAAM,IAAI,MAAM,8DAA8D;AAEhF,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,gBAAgB,WAAmB,WAAoB,WAAoB;AACzE,QAAI,cAAc;AAAc,WAAK,kBAAkB;AAAA,EACzD;AAAA,EAEA,uBAAuB;AACrB,SAAK,YAAY,QAAQ;AACzB,SAAK,qBAAqB;AAAA,EAC5B;AAAA,EAEA,oBAAoB;AAClB,SAAK,UAAU,iBAAiB,KAAK,SAAS,aAAa,MAAM;AAC/D,WAAK,YAAY,QAAQ;AACzB,WAAK,YAAY,WAAW,MAAM;AAChC,aAAK,aAAa,MAAM;AAAA,MAC1B,GAAG,KAAK,SAAS;AAAA,IACnB,CAAC;AACD,SAAK,UAAU,iBAAiB,KAAK,SAAS,YAAY,MAAM;AAC9D,WAAK,YAAY,QAAQ;AACzB,WAAK,YAAY,WAAW,MAAM;AAChC,aAAK,aAAa,QAAQ;AAAA,MAC5B,GAAG,KAAK,UAAU;AAAA,IACpB,CAAC;AACD,SAAK,UAAU,iBAAiB,KAAK,SAAS,SAAS,MAAM;AAC3D,WAAK,YAAY,QAAQ;AACzB,WAAK,aAAa,MAAM;AAAA,IAC1B,CAAC;AACD,SAAK,UAAU,iBAAiB,KAAK,SAAS,QAAQ,MAAM;AAC1D,WAAK,YAAY,QAAQ;AACzB,WAAK,aAAa,QAAQ;AAAA,IAC5B,CAAC;AACD,SAAK,UAAU,iBAAiB,KAAK,SAAS,SAAS,MAAM;AAC3D,WAAK,YAAY,QAAQ;AACzB,WAAK,aAAa,MAAM;AAAA,IAC1B,CAAC;AACD,SAAK,UAAU,iBAAiB,UAAU,WAAW,CAAC,UAAU;AAC9D,YAAM,EAAE,IAAI,IAAI;AAChB,UAAI,KAAK,UAAU,UAAU,QAAQ,UAAU;AAC7C,aAAK,aAAa,QAAQ;AAC1B,cAAM,gBAAgB;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,uBAAuB;AACrB,SAAK,UAAU,QAAQ;AAAA,EACzB;AAAA,EAEM,oBAAoB;AAAA;AACxB,UAAI,KAAK,UAAU,QAAQ;AACzB,aAAK,UAAU,MAAM,KAAK,QAAQ,QAAQ;AAE1C,aAAK,oBAAoB,KAAK,WAAW,QAAQ;AACjD,0BAAkB,KAAK,WAAW,OAAO;AAAA,MAC3C,OAAO;AACL,aAAK,UAAU,MAAM,KAAK,QAAQ,SAAS;AAE3C,cAAM,kBAAkB,KAAK,WAAW,OAAO;AAC/C,aAAK,iBAAiB,KAAK,WAAW,UAAU,MAAM;AAAA,MACxD;AAAA,IACF;AAAA;AACF;AAnFE;AAAA,EADC,MAAM,SAAS;AAAA,GADZ,eAEJ;AAEA;AAAA,EADC,MAAM,WAAW;AAAA,GAHd,eAIJ;AAGA;AAAA,EADC,KAAK,mBAAmB,MAAM;AAAA,GAN3B,eAOJ;AAEA;AAAA,EADC,KAAK,oBAAoB,MAAM;AAAA,GAR5B,eASJ;AA8EF,IAAM,UAAgC,OAAO;AAAA,EAC3C,MAAM,MAAM;AACV,mBAAe,OAAO,cAAc,cAAc;AAAA,EACpD;AACF;AAEA,IAAO,kBAAQ;;;AhBtFR,IAAM,qBAAyC,CAAC,SAAS;AAC9D,QAAM,aAAa,CAAC,eAAO,GAAG,GAAG,KAAK,UAAU;AAChD,SAAO;AAAA,IACL,gBAAgB,MAAM;AACpB,iBAAW,QAAQ,CAAC,SAAM;AAjBhC;AAiBmC,0BAAK,SAAL;AAAA,OAAa;AAAA,IAC5C;AAAA,IACA,OAAO,OAAO,OAAO,CAAC,GAAG,GAAG,WAAW,IAAI,CAAC,SAAM;AAnBtD;AAmByD,wBAAK,SAAL;AAAA,KAAa,CAAC;AAAA,IACnE,iBAAiB,CAAC,MAAmB,OAAoB;AACvD,iBAAW,QAAQ,CAAC,SAAM;AArBhC;AAqBmC,0BAAK,oBAAL,8BAAuB,MAAM;AAAA,OAAG;AAAA,IAC/D;AAAA,EACF;AACF;",
  "names": ["e", "candidateSelectors", "candidateSelector", "join", "NoElement", "Element", "matches", "prototype", "msMatchesSelector", "webkitMatchesSelector", "getRootNode", "element", "ownerDocument", "getCandidates", "el", "includeContainer", "filter", "candidates", "Array", "slice", "apply", "querySelectorAll", "call", "unshift", "getCandidatesIteratively", "elements", "options", "elementsToCheck", "from", "length", "shift", "tagName", "assigned", "assignedElements", "content", "children", "nestedCandidates", "flatten", "push", "scopeParent", "validCandidate", "includes", "shadowRoot", "getShadowRoot", "validShadowRoot", "shadowRootFilter", "getTabindex", "node", "isScope", "tabIndex", "test", "isContentEditable", "isNaN", "parseInt", "getAttribute", "sortOrderedTabbables", "a", "b", "documentOrder", "isInput", "isHiddenInput", "type", "isDetailsWithSummary", "r", "some", "child", "getCheckedRadio", "nodes", "form", "i", "checked", "isTabbableRadio", "name", "radioScope", "queryRadios", "radioSet", "window", "CSS", "escape", "err", "console", "error", "message", "isRadio", "isNonTabbableRadio", "isNodeAttached", "nodeRootHost", "host", "attached", "contains", "isZeroArea", "getBoundingClientRect", "width", "height", "isHidden", "displayCheck", "getComputedStyle", "visibility", "isDirectSummary", "nodeUnderDetails", "parentElement", "originalNode", "rootNode", "assignedSlot", "getClientRects", "isDisabledFromFieldset", "parentNode", "disabled", "item", "isNodeMatchingSelectorFocusable", "isNodeMatchingSelectorTabbable", "isValidShadowRootTabbable", "shadowHostNode", "sortByOrder", "regularTabbables", "orderedTabbables", "forEach", "candidateTabindex", "sort", "reduce", "acc", "sortable", "concat", "tabbable", "bind", "focusable", "isTabbable", "Error", "focusableCandidateSelector", "isFocusable", "rooTrapStack", "activeFocusTraps", "activateTrap", "trapStack", "trap", "length", "activeTrap", "pause", "trapIndex", "indexOf", "push", "splice", "deactivateTrap", "unpause", "isSelectableInput", "node", "tagName", "toLowerCase", "select", "isEscapeEvent", "e", "key", "keyCode", "isTabEvent", "delay", "fn", "setTimeout", "findIndex", "arr", "idx", "every", "value", "i", "valueOrHandler", "params", "getActualTarget", "event", "target", "shadowRoot", "composedPath", "createFocusTrap", "elements", "userOptions", "doc", "document", "config", "_objectSpread", "returnFocusOnDeactivate", "escapeDeactivates", "delayInitialFocus", "state", "containers", "containerGroups", "tabbableGroups", "nodeFocusedBeforeActivation", "mostRecentlyFocusedNode", "active", "paused", "delayInitialFocusTimer", "undefined", "getOption", "configOverrideOptions", "optionName", "configOptionName", "findContainerIndex", "element", "container", "tabbableNodes", "contains", "find", "getNodeForOption", "optionValue", "Error", "querySelector", "getInitialFocusNode", "activeElement", "firstTabbableGroup", "firstTabbableNode", "updateTabbableNodes", "map", "tabbable", "tabbableOptions", "focusableNodes", "focusable", "lastTabbableNode", "nextTabbableNode", "forward", "nodeIdx", "n", "slice", "isTabbable", "reverse", "filter", "group", "tryFocus", "focus", "preventScroll", "getReturnFocusNode", "previousActiveElement", "checkPointerDown", "clickOutsideDeactivates", "deactivate", "returnFocus", "isFocusable", "allowOutsideClick", "preventDefault", "checkFocusIn", "targetContained", "Document", "stopImmediatePropagation", "checkTab", "destinationNode", "containerIndex", "containerGroup", "shiftKey", "startOfGroupIndex", "destinationGroupIndex", "destinationGroup", "lastOfGroupIndex", "checkKey", "checkClick", "addListeners", "addEventListener", "capture", "passive", "removeListeners", "removeEventListener", "activate", "activateOptions", "onActivate", "onPostActivate", "checkCanFocusTrap", "finishActivation", "concat", "then", "deactivateOptions", "options", "onDeactivate", "onPostDeactivate", "checkCanReturnFocus", "clearTimeout", "finishDeactivation", "updateContainerElements", "containerElements", "elementsAsArray", "Boolean", "d", "v", "a", "z", "b", "d", "event", "_a", "t", "e", "i", "o", "a", "l", "s", "c", "f", "u", "m", "g", "d", "p", "n", "r", "h", "y", "x", "w", "v", "b", "R", "A", "P", "T", "O", "L", "D", "k", "E", "C", "e", "n", "r", "i", "o", "a", "l", "c", "f", "u", "m", "g", "h", "x", "w", "v", "b", "t", "R", "A", "P", "T", "O", "L", "D", "r", "i", "o", "a", "l", "s", "c", "f", "u", "m", "g", "d", "p", "h", "y", "t", "e", "n", "x", "w", "n", "t", "o", "e", "i", "r", "l", "c", "s", "f", "u", "d", "h", "a", "g", "m", "p", "w", "v", "y", "x", "b", "L", "E", "T", "D", "x", "y", "d"]
}
